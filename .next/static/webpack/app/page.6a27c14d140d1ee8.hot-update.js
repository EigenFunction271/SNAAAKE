"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/snake.tsx":
/*!*************************!*\
  !*** ./utils/snake.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Snake: function() { return /* binding */ Snake; }\n/* harmony export */ });\n// Snake segment interface\nclass Snake {\n    update(canvasWidth, canvasHeight) {\n        // Update velocity based on current angle\n        this.velocity = {\n            x: Math.cos(this.angle) * this.speed,\n            y: Math.sin(this.angle) * this.speed\n        };\n        // Move head\n        const head = this.segments[0];\n        const newHead = {\n            x: head.x + this.velocity.x,\n            y: head.y + this.velocity.y,\n            radius: head.radius\n        };\n        // Handle wrapping around edges (periodic boundary conditions)\n        let wrappedX = newHead.x;\n        let wrappedY = newHead.y;\n        if (newHead.x < 0) wrappedX = canvasWidth;\n        if (newHead.x > canvasWidth) wrappedX = 0;\n        if (newHead.y < 0) wrappedY = canvasHeight;\n        if (newHead.y > canvasHeight) wrappedY = 0;\n        // Add new position to history\n        this.history.unshift({\n            x: wrappedX,\n            y: wrappedY\n        });\n        this.history = this.history.slice(0, 1000) // Limit history length\n        ;\n        // Update head position\n        newHead.x = wrappedX;\n        newHead.y = wrappedY;\n        // Update segments\n        this.segments.unshift(newHead);\n        if (this.segments.length > this.targetLength) {\n            this.segments.pop();\n        }\n    }\n    draw(ctx) {\n        // Draw body segments with glow effect\n        ctx.shadowBlur = 20;\n        ctx.shadowColor = this.color;\n        ctx.fillStyle = this.color;\n        for(let i = this.segments.length - 1; i > 0; i--){\n            const segment = this.segments[i];\n            ctx.beginPath();\n            ctx.arc(segment.x, segment.y, segment.radius, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        // Draw head with different color and stronger glow\n        const head = this.segments[0];\n        ctx.shadowBlur = 30;\n        ctx.shadowColor = this.headColor;\n        ctx.fillStyle = this.headColor;\n        ctx.beginPath();\n        ctx.arc(head.x, head.y, head.radius, 0, Math.PI * 2);\n        ctx.fill();\n        // Reset shadow effect\n        ctx.shadowBlur = 0;\n    }\n    turnLeft() {\n        this.angle -= this.turningSpeed;\n    }\n    turnRight() {\n        this.angle += this.turningSpeed;\n    }\n    boost() {\n        this.speed = this.baseSpeed * 1.5;\n    }\n    normalSpeed() {\n        this.speed = this.baseSpeed;\n    }\n    grow(amount) {\n        this.targetLength += amount;\n    }\n    getHead() {\n        return this.segments[0];\n    }\n    checkSelfCollision() {\n        const head = this.getHead();\n        // Skip the first few segments to prevent false collisions\n        for(let i = 10; i < this.segments.length; i++){\n            const segment = this.segments[i];\n            const distance = Math.hypot(head.x - segment.x, head.y - segment.y);\n            if (distance < head.radius + segment.radius * 0.5) {\n                return true;\n            }\n        }\n        return false;\n    }\n    checkCollisionWithPoint(point) {\n        // Skip the head\n        for(let i = 1; i < this.segments.length; i++){\n            const segment = this.segments[i];\n            const distance = Math.hypot(point.x - segment.x, point.y - segment.y);\n            if (distance < point.radius + segment.radius * 0.8) {\n                return true;\n            }\n        }\n        return false;\n    }\n    collectPowerUp(powerUp) {\n        this.activePowerUps.set(powerUp.type, Date.now() + powerUp.duration);\n        powerUp.applyEffect(this);\n        AudioSystem.getInstance().playSound(\"powerup\");\n    }\n    constructor(options){\n        this.segments = [];\n        this.velocity = {\n            x: 0,\n            y: 0\n        };\n        this.turningSpeed = 0.05;\n        this.history = [];\n        this.isInvulnerable = false;\n        this.isGhost = false;\n        this.activePowerUps = new Map();\n        this.angle = options.initialAngle;\n        this.speed = options.speed;\n        this.baseSpeed = options.speed;\n        this.color = options.color;\n        this.headColor = options.headColor;\n        this.targetLength = options.initialLength;\n        // Initialize first segment (head)\n        this.segments.push({\n            x: options.x,\n            y: options.y,\n            radius: 12 // Head is slightly larger\n        });\n        // Add initial body segments\n        for(let i = 1; i < options.initialLength; i++){\n            this.segments.push({\n                x: options.x - i * Math.cos(options.initialAngle) * 20,\n                y: options.y - i * Math.sin(options.initialAngle) * 20,\n                radius: 10\n            });\n        }\n        // Initialize history with head position\n        for(let i = 0; i < 1000; i++){\n            this.history.push({\n                x: options.x,\n                y: options.y\n            });\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUM7WUFDakJqRSxHQUFHMkQsUUFBUTNELENBQUM7WUFDWkssR0FBR3NELFFBQVF0RCxDQUFDO1lBQ1pLLFFBQVEsR0FBRywwQkFBMEI7UUFDdkM7UUFFQSw0QkFBNEI7UUFDNUIsSUFBSyxJQUFJZSxJQUFJLEdBQUdBLElBQUlrQyxRQUFRSyxhQUFhLEVBQUV2QyxJQUFLO1lBQzlDLElBQUksQ0FBQ2pCLFFBQVEsQ0FBQ3lELElBQUksQ0FBQztnQkFDakJqRSxHQUFHMkQsUUFBUTNELENBQUMsR0FBR3lCLElBQUl4QixLQUFLQyxHQUFHLENBQUN5RCxRQUFRSSxZQUFZLElBQUk7Z0JBQ3BEMUQsR0FBR3NELFFBQVF0RCxDQUFDLEdBQUdvQixJQUFJeEIsS0FBS0ssR0FBRyxDQUFDcUQsUUFBUUksWUFBWSxJQUFJO2dCQUNwRHJELFFBQVE7WUFDVjtRQUNGO1FBRUEsd0NBQXdDO1FBQ3hDLElBQUssSUFBSWUsSUFBSSxHQUFHQSxJQUFJLE1BQU1BLElBQUs7WUFDN0IsSUFBSSxDQUFDWixPQUFPLENBQUNvRCxJQUFJLENBQUM7Z0JBQUVqRSxHQUFHMkQsUUFBUTNELENBQUM7Z0JBQUVLLEdBQUdzRCxRQUFRdEQsQ0FBQztZQUFDO1FBQ2pEO0lBQ0Y7QUE4SEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvc25ha2UudHN4PzY1MGEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU25ha2Ugc2VnbWVudCBpbnRlcmZhY2VcclxuaW50ZXJmYWNlIFNuYWtlU2VnbWVudCB7XHJcbiAgICB4OiBudW1iZXJcclxuICAgIHk6IG51bWJlclxyXG4gICAgcmFkaXVzOiBudW1iZXJcclxuICB9XHJcbiAgXHJcbiAgLy8gU25ha2Ugb3B0aW9ucyBpbnRlcmZhY2VcclxuICBpbnRlcmZhY2UgU25ha2VPcHRpb25zIHtcclxuICAgIHg6IG51bWJlclxyXG4gICAgeTogbnVtYmVyXHJcbiAgICBjb2xvcjogc3RyaW5nXHJcbiAgICBoZWFkQ29sb3I6IHN0cmluZ1xyXG4gICAgaW5pdGlhbExlbmd0aDogbnVtYmVyXHJcbiAgICBpbml0aWFsQW5nbGU6IG51bWJlclxyXG4gICAgc3BlZWQ6IG51bWJlclxyXG4gIH1cclxuICBcclxuICBleHBvcnQgY2xhc3MgU25ha2Uge1xyXG4gICAgc2VnbWVudHM6IFNuYWtlU2VnbWVudFtdID0gW11cclxuICAgIHZlbG9jaXR5ID0geyB4OiAwLCB5OiAwIH1cclxuICAgIGFuZ2xlOiBudW1iZXJcclxuICAgIHNwZWVkOiBudW1iZXJcclxuICAgIGJhc2VTcGVlZDogbnVtYmVyXHJcbiAgICB0dXJuaW5nU3BlZWQgPSAwLjA1XHJcbiAgICBjb2xvcjogc3RyaW5nXHJcbiAgICBoZWFkQ29sb3I6IHN0cmluZ1xyXG4gICAgdGFyZ2V0TGVuZ3RoOiBudW1iZXJcclxuICAgIGhpc3Rvcnk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfVtdID0gW11cclxuICAgIGlzSW52dWxuZXJhYmxlOiBib29sZWFuID0gZmFsc2VcclxuICAgIGlzR2hvc3Q6IGJvb2xlYW4gPSBmYWxzZVxyXG4gICAgYWN0aXZlUG93ZXJVcHM6IE1hcDxQb3dlclVwVHlwZSwgbnVtYmVyPiA9IG5ldyBNYXAoKVxyXG4gIFxyXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogU25ha2VPcHRpb25zKSB7XHJcbiAgICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmluaXRpYWxBbmdsZVxyXG4gICAgICB0aGlzLnNwZWVkID0gb3B0aW9ucy5zcGVlZFxyXG4gICAgICB0aGlzLmJhc2VTcGVlZCA9IG9wdGlvbnMuc3BlZWRcclxuICAgICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3JcclxuICAgICAgdGhpcy5oZWFkQ29sb3IgPSBvcHRpb25zLmhlYWRDb2xvclxyXG4gICAgICB0aGlzLnRhcmdldExlbmd0aCA9IG9wdGlvbnMuaW5pdGlhbExlbmd0aFxyXG4gIFxyXG4gICAgICAvLyBJbml0aWFsaXplIGZpcnN0IHNlZ21lbnQgKGhlYWQpXHJcbiAgICAgIHRoaXMuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgeDogb3B0aW9ucy54LFxyXG4gICAgICAgIHk6IG9wdGlvbnMueSxcclxuICAgICAgICByYWRpdXM6IDEyIC8vIEhlYWQgaXMgc2xpZ2h0bHkgbGFyZ2VyXHJcbiAgICAgIH0pXHJcbiAgXHJcbiAgICAgIC8vIEFkZCBpbml0aWFsIGJvZHkgc2VnbWVudHNcclxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBvcHRpb25zLmluaXRpYWxMZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICB4OiBvcHRpb25zLnggLSBpICogTWF0aC5jb3Mob3B0aW9ucy5pbml0aWFsQW5nbGUpICogMjAsXHJcbiAgICAgICAgICB5OiBvcHRpb25zLnkgLSBpICogTWF0aC5zaW4ob3B0aW9ucy5pbml0aWFsQW5nbGUpICogMjAsXHJcbiAgICAgICAgICByYWRpdXM6IDEwXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyBJbml0aWFsaXplIGhpc3Rvcnkgd2l0aCBoZWFkIHBvc2l0aW9uXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2goeyB4OiBvcHRpb25zLngsIHk6IG9wdGlvbnMueSB9KVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgXHJcbiAgICB1cGRhdGUoY2FudmFzV2lkdGg6IG51bWJlciwgY2FudmFzSGVpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgLy8gVXBkYXRlIHZlbG9jaXR5IGJhc2VkIG9uIGN1cnJlbnQgYW5nbGVcclxuICAgICAgdGhpcy52ZWxvY2l0eSA9IHtcclxuICAgICAgICB4OiBNYXRoLmNvcyh0aGlzLmFuZ2xlKSAqIHRoaXMuc3BlZWQsXHJcbiAgICAgICAgeTogTWF0aC5zaW4odGhpcy5hbmdsZSkgKiB0aGlzLnNwZWVkLFxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIE1vdmUgaGVhZFxyXG4gICAgICBjb25zdCBoZWFkID0gdGhpcy5zZWdtZW50c1swXVxyXG4gICAgICBjb25zdCBuZXdIZWFkID0ge1xyXG4gICAgICAgIHg6IGhlYWQueCArIHRoaXMudmVsb2NpdHkueCxcclxuICAgICAgICB5OiBoZWFkLnkgKyB0aGlzLnZlbG9jaXR5LnksXHJcbiAgICAgICAgcmFkaXVzOiBoZWFkLnJhZGl1c1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIEhhbmRsZSB3cmFwcGluZyBhcm91bmQgZWRnZXMgKHBlcmlvZGljIGJvdW5kYXJ5IGNvbmRpdGlvbnMpXHJcbiAgICAgIGxldCB3cmFwcGVkWCA9IG5ld0hlYWQueFxyXG4gICAgICBsZXQgd3JhcHBlZFkgPSBuZXdIZWFkLnlcclxuICBcclxuICAgICAgaWYgKG5ld0hlYWQueCA8IDApIHdyYXBwZWRYID0gY2FudmFzV2lkdGhcclxuICAgICAgaWYgKG5ld0hlYWQueCA+IGNhbnZhc1dpZHRoKSB3cmFwcGVkWCA9IDBcclxuICAgICAgaWYgKG5ld0hlYWQueSA8IDApIHdyYXBwZWRZID0gY2FudmFzSGVpZ2h0XHJcbiAgICAgIGlmIChuZXdIZWFkLnkgPiBjYW52YXNIZWlnaHQpIHdyYXBwZWRZID0gMFxyXG4gIFxyXG4gICAgICAvLyBBZGQgbmV3IHBvc2l0aW9uIHRvIGhpc3RvcnlcclxuICAgICAgdGhpcy5oaXN0b3J5LnVuc2hpZnQoeyB4OiB3cmFwcGVkWCwgeTogd3JhcHBlZFkgfSlcclxuICAgICAgdGhpcy5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5LnNsaWNlKDAsIDEwMDApIC8vIExpbWl0IGhpc3RvcnkgbGVuZ3RoXHJcbiAgXHJcbiAgICAgIC8vIFVwZGF0ZSBoZWFkIHBvc2l0aW9uXHJcbiAgICAgIG5ld0hlYWQueCA9IHdyYXBwZWRYXHJcbiAgICAgIG5ld0hlYWQueSA9IHdyYXBwZWRZXHJcbiAgXHJcbiAgICAgIC8vIFVwZGF0ZSBzZWdtZW50c1xyXG4gICAgICB0aGlzLnNlZ21lbnRzLnVuc2hpZnQobmV3SGVhZClcclxuICAgICAgaWYgKHRoaXMuc2VnbWVudHMubGVuZ3RoID4gdGhpcy50YXJnZXRMZW5ndGgpIHtcclxuICAgICAgICB0aGlzLnNlZ21lbnRzLnBvcCgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICBcclxuICAgIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgLy8gRHJhdyBib2R5IHNlZ21lbnRzIHdpdGggZ2xvdyBlZmZlY3RcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAyMFxyXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLmNvbG9yXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yXHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5zZWdtZW50cy5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHRoaXMuc2VnbWVudHNbaV1cclxuICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICBjdHguYXJjKHNlZ21lbnQueCwgc2VnbWVudC55LCBzZWdtZW50LnJhZGl1cywgMCwgTWF0aC5QSSAqIDIpXHJcbiAgICAgICAgY3R4LmZpbGwoKVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIERyYXcgaGVhZCB3aXRoIGRpZmZlcmVudCBjb2xvciBhbmQgc3Ryb25nZXIgZ2xvd1xyXG4gICAgICBjb25zdCBoZWFkID0gdGhpcy5zZWdtZW50c1swXVxyXG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDMwXHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuaGVhZENvbG9yXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmhlYWRDb2xvclxyXG4gICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgY3R4LmFyYyhoZWFkLngsIGhlYWQueSwgaGVhZC5yYWRpdXMsIDAsIE1hdGguUEkgKiAyKVxyXG4gICAgICBjdHguZmlsbCgpXHJcbiAgXHJcbiAgICAgIC8vIFJlc2V0IHNoYWRvdyBlZmZlY3RcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwXHJcbiAgICB9XHJcbiAgXHJcbiAgICB0dXJuTGVmdCgpIHtcclxuICAgICAgdGhpcy5hbmdsZSAtPSB0aGlzLnR1cm5pbmdTcGVlZFxyXG4gICAgfVxyXG4gIFxyXG4gICAgdHVyblJpZ2h0KCkge1xyXG4gICAgICB0aGlzLmFuZ2xlICs9IHRoaXMudHVybmluZ1NwZWVkXHJcbiAgICB9XHJcbiAgXHJcbiAgICBib29zdCgpIHtcclxuICAgICAgdGhpcy5zcGVlZCA9IHRoaXMuYmFzZVNwZWVkICogMS41XHJcbiAgICB9XHJcbiAgXHJcbiAgICBub3JtYWxTcGVlZCgpIHtcclxuICAgICAgdGhpcy5zcGVlZCA9IHRoaXMuYmFzZVNwZWVkXHJcbiAgICB9XHJcbiAgXHJcbiAgICBncm93KGFtb3VudDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMudGFyZ2V0TGVuZ3RoICs9IGFtb3VudFxyXG4gICAgfVxyXG4gIFxyXG4gICAgZ2V0SGVhZCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHNbMF1cclxuICAgIH1cclxuICBcclxuICAgIGNoZWNrU2VsZkNvbGxpc2lvbigpIHtcclxuICAgICAgY29uc3QgaGVhZCA9IHRoaXMuZ2V0SGVhZCgpXHJcbiAgXHJcbiAgICAgIC8vIFNraXAgdGhlIGZpcnN0IGZldyBzZWdtZW50cyB0byBwcmV2ZW50IGZhbHNlIGNvbGxpc2lvbnNcclxuICAgICAgZm9yIChsZXQgaSA9IDEwOyBpIDwgdGhpcy5zZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSB0aGlzLnNlZ21lbnRzW2ldXHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmh5cG90KGhlYWQueCAtIHNlZ21lbnQueCwgaGVhZC55IC0gc2VnbWVudC55KVxyXG4gIFxyXG4gICAgICAgIGlmIChkaXN0YW5jZSA8IGhlYWQucmFkaXVzICsgc2VnbWVudC5yYWRpdXMgKiAwLjUpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIFxyXG4gICAgY2hlY2tDb2xsaXNpb25XaXRoUG9pbnQocG9pbnQ6IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHJhZGl1czogbnVtYmVyIH0pIHtcclxuICAgICAgLy8gU2tpcCB0aGUgaGVhZFxyXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBzZWdtZW50ID0gdGhpcy5zZWdtZW50c1tpXVxyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5oeXBvdChwb2ludC54IC0gc2VnbWVudC54LCBwb2ludC55IC0gc2VnbWVudC55KVxyXG4gIFxyXG4gICAgICAgIGlmIChkaXN0YW5jZSA8IHBvaW50LnJhZGl1cyArIHNlZ21lbnQucmFkaXVzICogMC44KSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gIFxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICBcclxuICAgIGNvbGxlY3RQb3dlclVwKHBvd2VyVXA6IFBvd2VyVXApIHtcclxuICAgICAgdGhpcy5hY3RpdmVQb3dlclVwcy5zZXQocG93ZXJVcC50eXBlLCBEYXRlLm5vdygpICsgcG93ZXJVcC5kdXJhdGlvbilcclxuICAgICAgcG93ZXJVcC5hcHBseUVmZmVjdCh0aGlzKVxyXG4gICAgICBBdWRpb1N5c3RlbS5nZXRJbnN0YW5jZSgpLnBsYXlTb3VuZCgncG93ZXJ1cCcpXHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gICJdLCJuYW1lcyI6WyJTbmFrZSIsInVwZGF0ZSIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwidmVsb2NpdHkiLCJ4IiwiTWF0aCIsImNvcyIsImFuZ2xlIiwic3BlZWQiLCJ5Iiwic2luIiwiaGVhZCIsInNlZ21lbnRzIiwibmV3SGVhZCIsInJhZGl1cyIsIndyYXBwZWRYIiwid3JhcHBlZFkiLCJoaXN0b3J5IiwidW5zaGlmdCIsInNsaWNlIiwibGVuZ3RoIiwidGFyZ2V0TGVuZ3RoIiwicG9wIiwiZHJhdyIsImN0eCIsInNoYWRvd0JsdXIiLCJzaGFkb3dDb2xvciIsImNvbG9yIiwiZmlsbFN0eWxlIiwiaSIsInNlZ21lbnQiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGwiLCJoZWFkQ29sb3IiLCJ0dXJuTGVmdCIsInR1cm5pbmdTcGVlZCIsInR1cm5SaWdodCIsImJvb3N0IiwiYmFzZVNwZWVkIiwibm9ybWFsU3BlZWQiLCJncm93IiwiYW1vdW50IiwiZ2V0SGVhZCIsImNoZWNrU2VsZkNvbGxpc2lvbiIsImRpc3RhbmNlIiwiaHlwb3QiLCJjaGVja0NvbGxpc2lvbldpdGhQb2ludCIsInBvaW50IiwiY29sbGVjdFBvd2VyVXAiLCJwb3dlclVwIiwiYWN0aXZlUG93ZXJVcHMiLCJzZXQiLCJ0eXBlIiwiRGF0ZSIsIm5vdyIsImR1cmF0aW9uIiwiYXBwbHlFZmZlY3QiLCJBdWRpb1N5c3RlbSIsImdldEluc3RhbmNlIiwicGxheVNvdW5kIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiaXNJbnZ1bG5lcmFibGUiLCJpc0dob3N0IiwiTWFwIiwiaW5pdGlhbEFuZ2xlIiwiaW5pdGlhbExlbmd0aCIsInB1c2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/snake.tsx\n"));

/***/ })

});