"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/snake.tsx":
/*!*************************!*\
  !*** ./utils/snake.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Snake: function() { return /* binding */ Snake; }\n/* harmony export */ });\n/* harmony import */ var _audio_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audio-system */ \"(app-pages-browser)/./utils/audio-system.tsx\");\n\nclass Snake {\n    update(canvasWidth, canvasHeight) {\n        // Update velocity based on current angle\n        this.velocity = {\n            x: Math.cos(this.angle) * this.speed,\n            y: Math.sin(this.angle) * this.speed\n        };\n        // Move head\n        const head = this.segments[0];\n        const newX = head.x + this.velocity.x;\n        const newY = head.y + this.velocity.y;\n        // Handle wrapping around edges\n        let wrappedX = newX;\n        let wrappedY = newY;\n        if (newX < 0) wrappedX = canvasWidth;\n        if (newX > canvasWidth) wrappedX = 0;\n        if (newY < 0) wrappedY = canvasHeight;\n        if (newY > canvasHeight) wrappedY = 0;\n        // Add new position to history\n        this.history.unshift({\n            x: wrappedX,\n            y: wrappedY\n        });\n        this.history = this.history.slice(0, 1000);\n        // Update head position\n        head.x = wrappedX;\n        head.y = wrappedY;\n        // Update body segments to follow the head\n        for(let i = 1; i < this.segments.length; i++){\n            const segment = this.segments[i];\n            const historyPos = this.history[i * 5]; // Space segments out by using history\n            if (historyPos) {\n                segment.x = historyPos.x;\n                segment.y = historyPos.y;\n            }\n        }\n    }\n    draw(ctx) {\n        ctx.save();\n        // Apply visual effects based on power-ups\n        if (this.isInvulnerable) {\n            ctx.shadowColor = \"#f0f\";\n            ctx.shadowBlur = 20;\n        }\n        if (this.isGhost) {\n            ctx.globalAlpha = 0.6;\n        }\n        // Draw body segments\n        for(let i = this.segments.length - 1; i > 0; i--){\n            const segment = this.segments[i];\n            ctx.beginPath();\n            ctx.arc(segment.x, segment.y, segment.radius, 0, Math.PI * 2);\n            ctx.fillStyle = this.color;\n            ctx.fill();\n            // Add glow effect\n            ctx.shadowColor = this.color;\n            ctx.shadowBlur = 10;\n            ctx.fill();\n            ctx.shadowBlur = 0;\n        }\n        // Draw head\n        const head = this.segments[0];\n        ctx.beginPath();\n        ctx.arc(head.x, head.y, head.radius, 0, Math.PI * 2);\n        ctx.fillStyle = this.headColor;\n        ctx.fill();\n        // Add glow effect to head\n        ctx.shadowColor = this.headColor;\n        ctx.shadowBlur = 15;\n        ctx.fill();\n        ctx.shadowBlur = 0;\n        // Draw eyes\n        const eyeOffset = 3;\n        const eyeRadius = 2;\n        // Calculate eye positions based on angle\n        const leftEyeX = head.x + Math.cos(this.angle - 0.3) * eyeOffset;\n        const leftEyeY = head.y + Math.sin(this.angle - 0.3) * eyeOffset;\n        const rightEyeX = head.x + Math.cos(this.angle + 0.3) * eyeOffset;\n        const rightEyeY = head.y + Math.sin(this.angle + 0.3) * eyeOffset;\n        // Draw left eye\n        ctx.beginPath();\n        ctx.arc(leftEyeX, leftEyeY, eyeRadius, 0, Math.PI * 2);\n        ctx.fillStyle = \"#fff\";\n        ctx.fill();\n        // Draw right eye\n        ctx.beginPath();\n        ctx.arc(rightEyeX, rightEyeY, eyeRadius, 0, Math.PI * 2);\n        ctx.fillStyle = \"#fff\";\n        ctx.fill();\n        ctx.restore();\n    }\n    turnLeft() {\n        this.angle -= this.turningSpeed;\n        console.log(\"Turn left:\", {\n            newAngle: this.angle\n        });\n    }\n    turnRight() {\n        this.angle += this.turningSpeed;\n        console.log(\"Turn right:\", {\n            newAngle: this.angle\n        });\n    }\n    boost() {\n        this.speed = this.baseSpeed * 1.5;\n    }\n    normalSpeed() {\n        this.speed = this.baseSpeed;\n    }\n    grow(amount) {\n        // Increase target length\n        this.targetLength += amount;\n        // Add segments if needed\n        while(this.segments.length < this.targetLength){\n            const lastIndex = this.segments.length - 1;\n            const historyIndex = Math.min(lastIndex * 5, this.history.length - 1);\n            // Get position from history\n            const position = this.history[historyIndex];\n            // Add new segment\n            this.segments.push({\n                x: position.x,\n                y: position.y,\n                radius: 8 - Math.min(3, this.segments.length * 0.1)\n            });\n        }\n    }\n    getHead() {\n        return this.segments[0];\n    }\n    checkSelfCollision() {\n        const head = this.getHead();\n        // Skip the first few segments to prevent false collisions\n        for(let i = 10; i < this.segments.length; i++){\n            const segment = this.segments[i];\n            const distance = Math.hypot(head.x - segment.x, head.y - segment.y);\n            if (distance < head.radius + segment.radius * 0.5) {\n                return true;\n            }\n        }\n        return false;\n    }\n    checkCollisionWithPoint(point) {\n        // Skip the head\n        for(let i = 1; i < this.segments.length; i++){\n            const segment = this.segments[i];\n            const distance = Math.hypot(point.x - segment.x, point.y - segment.y);\n            if (distance < point.radius + segment.radius * 0.8) {\n                return true;\n            }\n        }\n        return false;\n    }\n    collectPowerUp(powerUp) {\n        this.activePowerUps.set(powerUp.type, Date.now() + powerUp.duration);\n        powerUp.applyEffect(this);\n        _audio_system__WEBPACK_IMPORTED_MODULE_0__.AudioSystem.getInstance().playSound(\"powerup\");\n    }\n    constructor(options){\n        this.segments = [];\n        this.velocity = {\n            x: 0,\n            y: 0\n        };\n        this.turningSpeed = 0.05;\n        this.history = [];\n        this.isInvulnerable = false;\n        this.isGhost = false;\n        this.activePowerUps = new Map();\n        this.angle = options.initialAngle;\n        this.speed = options.speed;\n        this.baseSpeed = options.speed;\n        this.color = options.color;\n        this.headColor = options.headColor;\n        this.targetLength = options.initialLength;\n        // Initialize first segment (head)\n        this.segments.push({\n            x: options.x,\n            y: options.y,\n            radius: 15 // Increased head radius for better collision detection\n        });\n        // Add initial body segments\n        for(let i = 1; i < options.initialLength; i++){\n            this.segments.push({\n                x: options.x - i * Math.cos(options.initialAngle) * 20,\n                y: options.y - i * Math.sin(options.initialAngle) * 20,\n                radius: 12 // Slightly larger body segments\n            });\n        }\n        // Initialize history with head position\n        for(let i = 0; i < 1000; i++){\n            this.history.push({\n                x: options.x,\n                y: options.y\n            });\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3NuYWtlLnRzeCIsIm1hcHBpbmdzIjoiOzs7OztBQUM2QztBQTBCcEMsTUFBTUM7SUE2Q1hDLE9BQU9DLFdBQW1CLEVBQUVDLFlBQW9CLEVBQUU7UUFDaEQseUNBQXlDO1FBQ3pDLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1lBQ2RDLEdBQUdDLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNDLEtBQUssSUFBSSxJQUFJLENBQUNDLEtBQUs7WUFDcENDLEdBQUdKLEtBQUtLLEdBQUcsQ0FBQyxJQUFJLENBQUNILEtBQUssSUFBSSxJQUFJLENBQUNDLEtBQUs7UUFDdEM7UUFFQSxZQUFZO1FBQ1osTUFBTUcsT0FBTyxJQUFJLENBQUNDLFFBQVEsQ0FBQyxFQUFFO1FBQzdCLE1BQU1DLE9BQU9GLEtBQUtQLENBQUMsR0FBRyxJQUFJLENBQUNELFFBQVEsQ0FBQ0MsQ0FBQztRQUNyQyxNQUFNVSxPQUFPSCxLQUFLRixDQUFDLEdBQUcsSUFBSSxDQUFDTixRQUFRLENBQUNNLENBQUM7UUFFckMsK0JBQStCO1FBQy9CLElBQUlNLFdBQVdGO1FBQ2YsSUFBSUcsV0FBV0Y7UUFFZixJQUFJRCxPQUFPLEdBQUdFLFdBQVdkO1FBQ3pCLElBQUlZLE9BQU9aLGFBQWFjLFdBQVc7UUFDbkMsSUFBSUQsT0FBTyxHQUFHRSxXQUFXZDtRQUN6QixJQUFJWSxPQUFPWixjQUFjYyxXQUFXO1FBRXBDLDhCQUE4QjtRQUM5QixJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDO1lBQUVkLEdBQUdXO1lBQVVOLEdBQUdPO1FBQVM7UUFDaEQsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUNFLEtBQUssQ0FBQyxHQUFHO1FBRXJDLHVCQUF1QjtRQUN2QlIsS0FBS1AsQ0FBQyxHQUFHVztRQUNUSixLQUFLRixDQUFDLEdBQUdPO1FBRVQsMENBQTBDO1FBQzFDLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ1IsUUFBUSxDQUFDUyxNQUFNLEVBQUVELElBQUs7WUFDN0MsTUFBTUUsVUFBVSxJQUFJLENBQUNWLFFBQVEsQ0FBQ1EsRUFBRTtZQUNoQyxNQUFNRyxhQUFhLElBQUksQ0FBQ04sT0FBTyxDQUFDRyxJQUFJLEVBQUUsRUFBRSxzQ0FBc0M7WUFDOUUsSUFBSUcsWUFBWTtnQkFDZEQsUUFBUWxCLENBQUMsR0FBR21CLFdBQVduQixDQUFDO2dCQUN4QmtCLFFBQVFiLENBQUMsR0FBR2MsV0FBV2QsQ0FBQztZQUMxQjtRQUNGO0lBQ0Y7SUFFQWUsS0FBS0MsR0FBNkIsRUFBRTtRQUNsQ0EsSUFBSUMsSUFBSTtRQUVSLDBDQUEwQztRQUMxQyxJQUFJLElBQUksQ0FBQ0MsY0FBYyxFQUFFO1lBQ3ZCRixJQUFJRyxXQUFXLEdBQUc7WUFDbEJILElBQUlJLFVBQVUsR0FBRztRQUNuQjtRQUVBLElBQUksSUFBSSxDQUFDQyxPQUFPLEVBQUU7WUFDaEJMLElBQUlNLFdBQVcsR0FBRztRQUNwQjtRQUVBLHFCQUFxQjtRQUNyQixJQUFLLElBQUlYLElBQUksSUFBSSxDQUFDUixRQUFRLENBQUNTLE1BQU0sR0FBRyxHQUFHRCxJQUFJLEdBQUdBLElBQUs7WUFDakQsTUFBTUUsVUFBVSxJQUFJLENBQUNWLFFBQVEsQ0FBQ1EsRUFBRTtZQUVoQ0ssSUFBSU8sU0FBUztZQUNiUCxJQUFJUSxHQUFHLENBQUNYLFFBQVFsQixDQUFDLEVBQUVrQixRQUFRYixDQUFDLEVBQUVhLFFBQVFZLE1BQU0sRUFBRSxHQUFHN0IsS0FBSzhCLEVBQUUsR0FBRztZQUMzRFYsSUFBSVcsU0FBUyxHQUFHLElBQUksQ0FBQ0MsS0FBSztZQUMxQlosSUFBSWEsSUFBSTtZQUVSLGtCQUFrQjtZQUNsQmIsSUFBSUcsV0FBVyxHQUFHLElBQUksQ0FBQ1MsS0FBSztZQUM1QlosSUFBSUksVUFBVSxHQUFHO1lBQ2pCSixJQUFJYSxJQUFJO1lBQ1JiLElBQUlJLFVBQVUsR0FBRztRQUNuQjtRQUVBLFlBQVk7UUFDWixNQUFNbEIsT0FBTyxJQUFJLENBQUNDLFFBQVEsQ0FBQyxFQUFFO1FBQzdCYSxJQUFJTyxTQUFTO1FBQ2JQLElBQUlRLEdBQUcsQ0FBQ3RCLEtBQUtQLENBQUMsRUFBRU8sS0FBS0YsQ0FBQyxFQUFFRSxLQUFLdUIsTUFBTSxFQUFFLEdBQUc3QixLQUFLOEIsRUFBRSxHQUFHO1FBQ2xEVixJQUFJVyxTQUFTLEdBQUcsSUFBSSxDQUFDRyxTQUFTO1FBQzlCZCxJQUFJYSxJQUFJO1FBRVIsMEJBQTBCO1FBQzFCYixJQUFJRyxXQUFXLEdBQUcsSUFBSSxDQUFDVyxTQUFTO1FBQ2hDZCxJQUFJSSxVQUFVLEdBQUc7UUFDakJKLElBQUlhLElBQUk7UUFDUmIsSUFBSUksVUFBVSxHQUFHO1FBRWpCLFlBQVk7UUFDWixNQUFNVyxZQUFZO1FBQ2xCLE1BQU1DLFlBQVk7UUFFbEIseUNBQXlDO1FBQ3pDLE1BQU1DLFdBQVcvQixLQUFLUCxDQUFDLEdBQUdDLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNDLEtBQUssR0FBRyxPQUFPaUM7UUFDdkQsTUFBTUcsV0FBV2hDLEtBQUtGLENBQUMsR0FBR0osS0FBS0ssR0FBRyxDQUFDLElBQUksQ0FBQ0gsS0FBSyxHQUFHLE9BQU9pQztRQUN2RCxNQUFNSSxZQUFZakMsS0FBS1AsQ0FBQyxHQUFHQyxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDQyxLQUFLLEdBQUcsT0FBT2lDO1FBQ3hELE1BQU1LLFlBQVlsQyxLQUFLRixDQUFDLEdBQUdKLEtBQUtLLEdBQUcsQ0FBQyxJQUFJLENBQUNILEtBQUssR0FBRyxPQUFPaUM7UUFFeEQsZ0JBQWdCO1FBQ2hCZixJQUFJTyxTQUFTO1FBQ2JQLElBQUlRLEdBQUcsQ0FBQ1MsVUFBVUMsVUFBVUYsV0FBVyxHQUFHcEMsS0FBSzhCLEVBQUUsR0FBRztRQUNwRFYsSUFBSVcsU0FBUyxHQUFHO1FBQ2hCWCxJQUFJYSxJQUFJO1FBRVIsaUJBQWlCO1FBQ2pCYixJQUFJTyxTQUFTO1FBQ2JQLElBQUlRLEdBQUcsQ0FBQ1csV0FBV0MsV0FBV0osV0FBVyxHQUFHcEMsS0FBSzhCLEVBQUUsR0FBRztRQUN0RFYsSUFBSVcsU0FBUyxHQUFHO1FBQ2hCWCxJQUFJYSxJQUFJO1FBRVJiLElBQUlxQixPQUFPO0lBQ2I7SUFFQUMsV0FBVztRQUNULElBQUksQ0FBQ3hDLEtBQUssSUFBSSxJQUFJLENBQUN5QyxZQUFZO1FBQy9CQyxRQUFRQyxHQUFHLENBQUMsY0FBYztZQUFFQyxVQUFVLElBQUksQ0FBQzVDLEtBQUs7UUFBQztJQUNuRDtJQUVBNkMsWUFBWTtRQUNWLElBQUksQ0FBQzdDLEtBQUssSUFBSSxJQUFJLENBQUN5QyxZQUFZO1FBQy9CQyxRQUFRQyxHQUFHLENBQUMsZUFBZTtZQUFFQyxVQUFVLElBQUksQ0FBQzVDLEtBQUs7UUFBQztJQUNwRDtJQUVBOEMsUUFBUTtRQUNOLElBQUksQ0FBQzdDLEtBQUssR0FBRyxJQUFJLENBQUM4QyxTQUFTLEdBQUc7SUFDaEM7SUFFQUMsY0FBYztRQUNaLElBQUksQ0FBQy9DLEtBQUssR0FBRyxJQUFJLENBQUM4QyxTQUFTO0lBQzdCO0lBRUFFLEtBQUtDLE1BQWMsRUFBRTtRQUNuQix5QkFBeUI7UUFDekIsSUFBSSxDQUFDQyxZQUFZLElBQUlEO1FBRXJCLHlCQUF5QjtRQUN6QixNQUFPLElBQUksQ0FBQzdDLFFBQVEsQ0FBQ1MsTUFBTSxHQUFHLElBQUksQ0FBQ3FDLFlBQVksQ0FBRTtZQUMvQyxNQUFNQyxZQUFZLElBQUksQ0FBQy9DLFFBQVEsQ0FBQ1MsTUFBTSxHQUFHO1lBQ3pDLE1BQU11QyxlQUFldkQsS0FBS3dELEdBQUcsQ0FBQ0YsWUFBWSxHQUFHLElBQUksQ0FBQzFDLE9BQU8sQ0FBQ0ksTUFBTSxHQUFHO1lBRW5FLDRCQUE0QjtZQUM1QixNQUFNeUMsV0FBVyxJQUFJLENBQUM3QyxPQUFPLENBQUMyQyxhQUFhO1lBRTNDLGtCQUFrQjtZQUNsQixJQUFJLENBQUNoRCxRQUFRLENBQUNtRCxJQUFJLENBQUM7Z0JBQ2pCM0QsR0FBRzBELFNBQVMxRCxDQUFDO2dCQUNiSyxHQUFHcUQsU0FBU3JELENBQUM7Z0JBQ2J5QixRQUFRLElBQUk3QixLQUFLd0QsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDakQsUUFBUSxDQUFDUyxNQUFNLEdBQUc7WUFDakQ7UUFDRjtJQUNGO0lBRUEyQyxVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUNwRCxRQUFRLENBQUMsRUFBRTtJQUN6QjtJQUVBcUQscUJBQXFCO1FBQ25CLE1BQU10RCxPQUFPLElBQUksQ0FBQ3FELE9BQU87UUFFekIsMERBQTBEO1FBQzFELElBQUssSUFBSTVDLElBQUksSUFBSUEsSUFBSSxJQUFJLENBQUNSLFFBQVEsQ0FBQ1MsTUFBTSxFQUFFRCxJQUFLO1lBQzlDLE1BQU1FLFVBQVUsSUFBSSxDQUFDVixRQUFRLENBQUNRLEVBQUU7WUFDaEMsTUFBTThDLFdBQVc3RCxLQUFLOEQsS0FBSyxDQUFDeEQsS0FBS1AsQ0FBQyxHQUFHa0IsUUFBUWxCLENBQUMsRUFBRU8sS0FBS0YsQ0FBQyxHQUFHYSxRQUFRYixDQUFDO1lBRWxFLElBQUl5RCxXQUFXdkQsS0FBS3VCLE1BQU0sR0FBR1osUUFBUVksTUFBTSxHQUFHLEtBQUs7Z0JBQ2pELE9BQU87WUFDVDtRQUNGO1FBRUEsT0FBTztJQUNUO0lBRUFrQyx3QkFBd0JDLEtBQStDLEVBQUU7UUFDdkUsZ0JBQWdCO1FBQ2hCLElBQUssSUFBSWpELElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNSLFFBQVEsQ0FBQ1MsTUFBTSxFQUFFRCxJQUFLO1lBQzdDLE1BQU1FLFVBQVUsSUFBSSxDQUFDVixRQUFRLENBQUNRLEVBQUU7WUFDaEMsTUFBTThDLFdBQVc3RCxLQUFLOEQsS0FBSyxDQUFDRSxNQUFNakUsQ0FBQyxHQUFHa0IsUUFBUWxCLENBQUMsRUFBRWlFLE1BQU01RCxDQUFDLEdBQUdhLFFBQVFiLENBQUM7WUFFcEUsSUFBSXlELFdBQVdHLE1BQU1uQyxNQUFNLEdBQUdaLFFBQVFZLE1BQU0sR0FBRyxLQUFLO2dCQUNsRCxPQUFPO1lBQ1Q7UUFDRjtRQUVBLE9BQU87SUFDVDtJQUVBb0MsZUFBZUMsT0FBZ0IsRUFBRTtRQUMvQixJQUFJLENBQUNDLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDRixRQUFRRyxJQUFJLEVBQUVDLEtBQUtDLEdBQUcsS0FBS0wsUUFBUU0sUUFBUTtRQUNuRU4sUUFBUU8sV0FBVyxDQUFDLElBQUk7UUFDeEJoRixzREFBV0EsQ0FBQ2lGLFdBQVcsR0FBR0MsU0FBUyxDQUFDO0lBQ3RDO0lBdE5BQyxZQUFZQyxPQUFxQixDQUFFO2FBZG5DdEUsV0FBMkIsRUFBRTthQUM3QlQsV0FBVztZQUFFQyxHQUFHO1lBQUdLLEdBQUc7UUFBRTthQUl4QnVDLGVBQWU7YUFJZi9CLFVBQXNDLEVBQUU7YUFDeENVLGlCQUEwQjthQUMxQkcsVUFBbUI7YUFDbkIwQyxpQkFBMkMsSUFBSVc7UUFHN0MsSUFBSSxDQUFDNUUsS0FBSyxHQUFHMkUsUUFBUUUsWUFBWTtRQUNqQyxJQUFJLENBQUM1RSxLQUFLLEdBQUcwRSxRQUFRMUUsS0FBSztRQUMxQixJQUFJLENBQUM4QyxTQUFTLEdBQUc0QixRQUFRMUUsS0FBSztRQUM5QixJQUFJLENBQUM2QixLQUFLLEdBQUc2QyxRQUFRN0MsS0FBSztRQUMxQixJQUFJLENBQUNFLFNBQVMsR0FBRzJDLFFBQVEzQyxTQUFTO1FBQ2xDLElBQUksQ0FBQ21CLFlBQVksR0FBR3dCLFFBQVFHLGFBQWE7UUFFekMsa0NBQWtDO1FBQ2xDLElBQUksQ0FBQ3pFLFFBQVEsQ0FBQ21ELElBQUksQ0FBQztZQUNqQjNELEdBQUc4RSxRQUFROUUsQ0FBQztZQUNaSyxHQUFHeUUsUUFBUXpFLENBQUM7WUFDWnlCLFFBQVEsR0FBSSx1REFBdUQ7UUFDckU7UUFFQSw0QkFBNEI7UUFDNUIsSUFBSyxJQUFJZCxJQUFJLEdBQUdBLElBQUk4RCxRQUFRRyxhQUFhLEVBQUVqRSxJQUFLO1lBQzlDLElBQUksQ0FBQ1IsUUFBUSxDQUFDbUQsSUFBSSxDQUFDO2dCQUNqQjNELEdBQUc4RSxRQUFROUUsQ0FBQyxHQUFHZ0IsSUFBSWYsS0FBS0MsR0FBRyxDQUFDNEUsUUFBUUUsWUFBWSxJQUFJO2dCQUNwRDNFLEdBQUd5RSxRQUFRekUsQ0FBQyxHQUFHVyxJQUFJZixLQUFLSyxHQUFHLENBQUN3RSxRQUFRRSxZQUFZLElBQUk7Z0JBQ3BEbEQsUUFBUSxHQUFJLGdDQUFnQztZQUM5QztRQUNGO1FBRUEsd0NBQXdDO1FBQ3hDLElBQUssSUFBSWQsSUFBSSxHQUFHQSxJQUFJLE1BQU1BLElBQUs7WUFDN0IsSUFBSSxDQUFDSCxPQUFPLENBQUM4QyxJQUFJLENBQUM7Z0JBQUUzRCxHQUFHOEUsUUFBUTlFLENBQUM7Z0JBQUVLLEdBQUd5RSxRQUFRekUsQ0FBQztZQUFDO1FBQ2pEO0lBQ0Y7QUEyTEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvc25ha2UudHN4PzY1MGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG93ZXJVcFR5cGUgfSBmcm9tICcuL3Bvd2VyLXVwJztcclxuaW1wb3J0IHsgQXVkaW9TeXN0ZW0gfSBmcm9tICcuL2F1ZGlvLXN5c3RlbSc7XHJcblxyXG5pbnRlcmZhY2UgUG93ZXJVcCB7XHJcbiAgdHlwZTogUG93ZXJVcFR5cGU7XHJcbiAgZHVyYXRpb246IG51bWJlcjtcclxuICBhcHBseUVmZmVjdDogKHNuYWtlOiBTbmFrZSkgPT4gdm9pZDtcclxufVxyXG5cclxuLy8gU25ha2Ugc2VnbWVudCBpbnRlcmZhY2VcclxuaW50ZXJmYWNlIFNuYWtlU2VnbWVudCB7XHJcbiAgICB4OiBudW1iZXJcclxuICAgIHk6IG51bWJlclxyXG4gICAgcmFkaXVzOiBudW1iZXJcclxuICB9XHJcbiAgXHJcbiAgLy8gU25ha2Ugb3B0aW9ucyBpbnRlcmZhY2VcclxuICBpbnRlcmZhY2UgU25ha2VPcHRpb25zIHtcclxuICAgIHg6IG51bWJlclxyXG4gICAgeTogbnVtYmVyXHJcbiAgICBjb2xvcjogc3RyaW5nXHJcbiAgICBoZWFkQ29sb3I6IHN0cmluZ1xyXG4gICAgaW5pdGlhbExlbmd0aDogbnVtYmVyXHJcbiAgICBpbml0aWFsQW5nbGU6IG51bWJlclxyXG4gICAgc3BlZWQ6IG51bWJlclxyXG4gIH1cclxuICBcclxuICBleHBvcnQgY2xhc3MgU25ha2Uge1xyXG4gICAgc2VnbWVudHM6IFNuYWtlU2VnbWVudFtdID0gW11cclxuICAgIHZlbG9jaXR5ID0geyB4OiAwLCB5OiAwIH1cclxuICAgIGFuZ2xlOiBudW1iZXJcclxuICAgIHNwZWVkOiBudW1iZXJcclxuICAgIGJhc2VTcGVlZDogbnVtYmVyXHJcbiAgICB0dXJuaW5nU3BlZWQgPSAwLjA1XHJcbiAgICBjb2xvcjogc3RyaW5nXHJcbiAgICBoZWFkQ29sb3I6IHN0cmluZ1xyXG4gICAgdGFyZ2V0TGVuZ3RoOiBudW1iZXJcclxuICAgIGhpc3Rvcnk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfVtdID0gW11cclxuICAgIGlzSW52dWxuZXJhYmxlOiBib29sZWFuID0gZmFsc2VcclxuICAgIGlzR2hvc3Q6IGJvb2xlYW4gPSBmYWxzZVxyXG4gICAgYWN0aXZlUG93ZXJVcHM6IE1hcDxQb3dlclVwVHlwZSwgbnVtYmVyPiA9IG5ldyBNYXAoKVxyXG4gIFxyXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogU25ha2VPcHRpb25zKSB7XHJcbiAgICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmluaXRpYWxBbmdsZVxyXG4gICAgICB0aGlzLnNwZWVkID0gb3B0aW9ucy5zcGVlZFxyXG4gICAgICB0aGlzLmJhc2VTcGVlZCA9IG9wdGlvbnMuc3BlZWRcclxuICAgICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3JcclxuICAgICAgdGhpcy5oZWFkQ29sb3IgPSBvcHRpb25zLmhlYWRDb2xvclxyXG4gICAgICB0aGlzLnRhcmdldExlbmd0aCA9IG9wdGlvbnMuaW5pdGlhbExlbmd0aFxyXG4gIFxyXG4gICAgICAvLyBJbml0aWFsaXplIGZpcnN0IHNlZ21lbnQgKGhlYWQpXHJcbiAgICAgIHRoaXMuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgeDogb3B0aW9ucy54LFxyXG4gICAgICAgIHk6IG9wdGlvbnMueSxcclxuICAgICAgICByYWRpdXM6IDE1ICAvLyBJbmNyZWFzZWQgaGVhZCByYWRpdXMgZm9yIGJldHRlciBjb2xsaXNpb24gZGV0ZWN0aW9uXHJcbiAgICAgIH0pXHJcbiAgXHJcbiAgICAgIC8vIEFkZCBpbml0aWFsIGJvZHkgc2VnbWVudHNcclxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBvcHRpb25zLmluaXRpYWxMZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICB4OiBvcHRpb25zLnggLSBpICogTWF0aC5jb3Mob3B0aW9ucy5pbml0aWFsQW5nbGUpICogMjAsXHJcbiAgICAgICAgICB5OiBvcHRpb25zLnkgLSBpICogTWF0aC5zaW4ob3B0aW9ucy5pbml0aWFsQW5nbGUpICogMjAsXHJcbiAgICAgICAgICByYWRpdXM6IDEyICAvLyBTbGlnaHRseSBsYXJnZXIgYm9keSBzZWdtZW50c1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLy8gSW5pdGlhbGl6ZSBoaXN0b3J5IHdpdGggaGVhZCBwb3NpdGlvblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDA7IGkrKykge1xyXG4gICAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKHsgeDogb3B0aW9ucy54LCB5OiBvcHRpb25zLnkgfSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgdXBkYXRlKGNhbnZhc1dpZHRoOiBudW1iZXIsIGNhbnZhc0hlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgIC8vIFVwZGF0ZSB2ZWxvY2l0eSBiYXNlZCBvbiBjdXJyZW50IGFuZ2xlXHJcbiAgICAgIHRoaXMudmVsb2NpdHkgPSB7XHJcbiAgICAgICAgeDogTWF0aC5jb3ModGhpcy5hbmdsZSkgKiB0aGlzLnNwZWVkLFxyXG4gICAgICAgIHk6IE1hdGguc2luKHRoaXMuYW5nbGUpICogdGhpcy5zcGVlZCxcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyBNb3ZlIGhlYWRcclxuICAgICAgY29uc3QgaGVhZCA9IHRoaXMuc2VnbWVudHNbMF07XHJcbiAgICAgIGNvbnN0IG5ld1ggPSBoZWFkLnggKyB0aGlzLnZlbG9jaXR5Lng7XHJcbiAgICAgIGNvbnN0IG5ld1kgPSBoZWFkLnkgKyB0aGlzLnZlbG9jaXR5Lnk7XHJcbiAgXHJcbiAgICAgIC8vIEhhbmRsZSB3cmFwcGluZyBhcm91bmQgZWRnZXNcclxuICAgICAgbGV0IHdyYXBwZWRYID0gbmV3WDtcclxuICAgICAgbGV0IHdyYXBwZWRZID0gbmV3WTtcclxuICBcclxuICAgICAgaWYgKG5ld1ggPCAwKSB3cmFwcGVkWCA9IGNhbnZhc1dpZHRoO1xyXG4gICAgICBpZiAobmV3WCA+IGNhbnZhc1dpZHRoKSB3cmFwcGVkWCA9IDA7XHJcbiAgICAgIGlmIChuZXdZIDwgMCkgd3JhcHBlZFkgPSBjYW52YXNIZWlnaHQ7XHJcbiAgICAgIGlmIChuZXdZID4gY2FudmFzSGVpZ2h0KSB3cmFwcGVkWSA9IDA7XHJcbiAgXHJcbiAgICAgIC8vIEFkZCBuZXcgcG9zaXRpb24gdG8gaGlzdG9yeVxyXG4gICAgICB0aGlzLmhpc3RvcnkudW5zaGlmdCh7IHg6IHdyYXBwZWRYLCB5OiB3cmFwcGVkWSB9KTtcclxuICAgICAgdGhpcy5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5LnNsaWNlKDAsIDEwMDApO1xyXG4gIFxyXG4gICAgICAvLyBVcGRhdGUgaGVhZCBwb3NpdGlvblxyXG4gICAgICBoZWFkLnggPSB3cmFwcGVkWDtcclxuICAgICAgaGVhZC55ID0gd3JhcHBlZFk7XHJcbiAgXHJcbiAgICAgIC8vIFVwZGF0ZSBib2R5IHNlZ21lbnRzIHRvIGZvbGxvdyB0aGUgaGVhZFxyXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBzZWdtZW50ID0gdGhpcy5zZWdtZW50c1tpXTtcclxuICAgICAgICBjb25zdCBoaXN0b3J5UG9zID0gdGhpcy5oaXN0b3J5W2kgKiA1XTsgLy8gU3BhY2Ugc2VnbWVudHMgb3V0IGJ5IHVzaW5nIGhpc3RvcnlcclxuICAgICAgICBpZiAoaGlzdG9yeVBvcykge1xyXG4gICAgICAgICAgc2VnbWVudC54ID0gaGlzdG9yeVBvcy54O1xyXG4gICAgICAgICAgc2VnbWVudC55ID0gaGlzdG9yeVBvcy55O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBjdHguc2F2ZSgpXHJcbiAgICAgIFxyXG4gICAgICAvLyBBcHBseSB2aXN1YWwgZWZmZWN0cyBiYXNlZCBvbiBwb3dlci11cHNcclxuICAgICAgaWYgKHRoaXMuaXNJbnZ1bG5lcmFibGUpIHtcclxuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAnI2YwZidcclxuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDIwXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmICh0aGlzLmlzR2hvc3QpIHtcclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjZcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyBEcmF3IGJvZHkgc2VnbWVudHNcclxuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc2VnbWVudHMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSB0aGlzLnNlZ21lbnRzW2ldXHJcbiAgXHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgY3R4LmFyYyhzZWdtZW50LngsIHNlZ21lbnQueSwgc2VnbWVudC5yYWRpdXMsIDAsIE1hdGguUEkgKiAyKVxyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yXHJcbiAgICAgICAgY3R4LmZpbGwoKVxyXG4gIFxyXG4gICAgICAgIC8vIEFkZCBnbG93IGVmZmVjdFxyXG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuY29sb3JcclxuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDEwXHJcbiAgICAgICAgY3R4LmZpbGwoKVxyXG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMFxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIERyYXcgaGVhZFxyXG4gICAgICBjb25zdCBoZWFkID0gdGhpcy5zZWdtZW50c1swXVxyXG4gICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgY3R4LmFyYyhoZWFkLngsIGhlYWQueSwgaGVhZC5yYWRpdXMsIDAsIE1hdGguUEkgKiAyKVxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5oZWFkQ29sb3JcclxuICAgICAgY3R4LmZpbGwoKVxyXG4gIFxyXG4gICAgICAvLyBBZGQgZ2xvdyBlZmZlY3QgdG8gaGVhZFxyXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLmhlYWRDb2xvclxyXG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDE1XHJcbiAgICAgIGN0eC5maWxsKClcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwXHJcbiAgXHJcbiAgICAgIC8vIERyYXcgZXllc1xyXG4gICAgICBjb25zdCBleWVPZmZzZXQgPSAzXHJcbiAgICAgIGNvbnN0IGV5ZVJhZGl1cyA9IDJcclxuICBcclxuICAgICAgLy8gQ2FsY3VsYXRlIGV5ZSBwb3NpdGlvbnMgYmFzZWQgb24gYW5nbGVcclxuICAgICAgY29uc3QgbGVmdEV5ZVggPSBoZWFkLnggKyBNYXRoLmNvcyh0aGlzLmFuZ2xlIC0gMC4zKSAqIGV5ZU9mZnNldFxyXG4gICAgICBjb25zdCBsZWZ0RXllWSA9IGhlYWQueSArIE1hdGguc2luKHRoaXMuYW5nbGUgLSAwLjMpICogZXllT2Zmc2V0XHJcbiAgICAgIGNvbnN0IHJpZ2h0RXllWCA9IGhlYWQueCArIE1hdGguY29zKHRoaXMuYW5nbGUgKyAwLjMpICogZXllT2Zmc2V0XHJcbiAgICAgIGNvbnN0IHJpZ2h0RXllWSA9IGhlYWQueSArIE1hdGguc2luKHRoaXMuYW5nbGUgKyAwLjMpICogZXllT2Zmc2V0XHJcbiAgXHJcbiAgICAgIC8vIERyYXcgbGVmdCBleWVcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgIGN0eC5hcmMobGVmdEV5ZVgsIGxlZnRFeWVZLCBleWVSYWRpdXMsIDAsIE1hdGguUEkgKiAyKVxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmXCJcclxuICAgICAgY3R4LmZpbGwoKVxyXG4gIFxyXG4gICAgICAvLyBEcmF3IHJpZ2h0IGV5ZVxyXG4gICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgY3R4LmFyYyhyaWdodEV5ZVgsIHJpZ2h0RXllWSwgZXllUmFkaXVzLCAwLCBNYXRoLlBJICogMilcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZlwiXHJcbiAgICAgIGN0eC5maWxsKClcclxuICBcclxuICAgICAgY3R4LnJlc3RvcmUoKVxyXG4gICAgfVxyXG4gIFxyXG4gICAgdHVybkxlZnQoKSB7XHJcbiAgICAgIHRoaXMuYW5nbGUgLT0gdGhpcy50dXJuaW5nU3BlZWRcclxuICAgICAgY29uc29sZS5sb2coJ1R1cm4gbGVmdDonLCB7IG5ld0FuZ2xlOiB0aGlzLmFuZ2xlIH0pXHJcbiAgICB9XHJcbiAgXHJcbiAgICB0dXJuUmlnaHQoKSB7XHJcbiAgICAgIHRoaXMuYW5nbGUgKz0gdGhpcy50dXJuaW5nU3BlZWRcclxuICAgICAgY29uc29sZS5sb2coJ1R1cm4gcmlnaHQ6JywgeyBuZXdBbmdsZTogdGhpcy5hbmdsZSB9KVxyXG4gICAgfVxyXG4gIFxyXG4gICAgYm9vc3QoKSB7XHJcbiAgICAgIHRoaXMuc3BlZWQgPSB0aGlzLmJhc2VTcGVlZCAqIDEuNVxyXG4gICAgfVxyXG4gIFxyXG4gICAgbm9ybWFsU3BlZWQoKSB7XHJcbiAgICAgIHRoaXMuc3BlZWQgPSB0aGlzLmJhc2VTcGVlZFxyXG4gICAgfVxyXG4gIFxyXG4gICAgZ3JvdyhhbW91bnQ6IG51bWJlcikge1xyXG4gICAgICAvLyBJbmNyZWFzZSB0YXJnZXQgbGVuZ3RoXHJcbiAgICAgIHRoaXMudGFyZ2V0TGVuZ3RoICs9IGFtb3VudFxyXG4gIFxyXG4gICAgICAvLyBBZGQgc2VnbWVudHMgaWYgbmVlZGVkXHJcbiAgICAgIHdoaWxlICh0aGlzLnNlZ21lbnRzLmxlbmd0aCA8IHRoaXMudGFyZ2V0TGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gdGhpcy5zZWdtZW50cy5sZW5ndGggLSAxXHJcbiAgICAgICAgY29uc3QgaGlzdG9yeUluZGV4ID0gTWF0aC5taW4obGFzdEluZGV4ICogNSwgdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDEpXHJcbiAgXHJcbiAgICAgICAgLy8gR2V0IHBvc2l0aW9uIGZyb20gaGlzdG9yeVxyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5oaXN0b3J5W2hpc3RvcnlJbmRleF1cclxuICBcclxuICAgICAgICAvLyBBZGQgbmV3IHNlZ21lbnRcclxuICAgICAgICB0aGlzLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgeDogcG9zaXRpb24ueCxcclxuICAgICAgICAgIHk6IHBvc2l0aW9uLnksXHJcbiAgICAgICAgICByYWRpdXM6IDggLSBNYXRoLm1pbigzLCB0aGlzLnNlZ21lbnRzLmxlbmd0aCAqIDAuMSksIC8vIEdyYWR1YWxseSBkZWNyZWFzZSBzaXplXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgZ2V0SGVhZCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHNbMF1cclxuICAgIH1cclxuICBcclxuICAgIGNoZWNrU2VsZkNvbGxpc2lvbigpIHtcclxuICAgICAgY29uc3QgaGVhZCA9IHRoaXMuZ2V0SGVhZCgpXHJcbiAgXHJcbiAgICAgIC8vIFNraXAgdGhlIGZpcnN0IGZldyBzZWdtZW50cyB0byBwcmV2ZW50IGZhbHNlIGNvbGxpc2lvbnNcclxuICAgICAgZm9yIChsZXQgaSA9IDEwOyBpIDwgdGhpcy5zZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSB0aGlzLnNlZ21lbnRzW2ldXHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmh5cG90KGhlYWQueCAtIHNlZ21lbnQueCwgaGVhZC55IC0gc2VnbWVudC55KVxyXG4gIFxyXG4gICAgICAgIGlmIChkaXN0YW5jZSA8IGhlYWQucmFkaXVzICsgc2VnbWVudC5yYWRpdXMgKiAwLjUpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIFxyXG4gICAgY2hlY2tDb2xsaXNpb25XaXRoUG9pbnQocG9pbnQ6IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHJhZGl1czogbnVtYmVyIH0pIHtcclxuICAgICAgLy8gU2tpcCB0aGUgaGVhZFxyXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBzZWdtZW50ID0gdGhpcy5zZWdtZW50c1tpXVxyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5oeXBvdChwb2ludC54IC0gc2VnbWVudC54LCBwb2ludC55IC0gc2VnbWVudC55KVxyXG4gIFxyXG4gICAgICAgIGlmIChkaXN0YW5jZSA8IHBvaW50LnJhZGl1cyArIHNlZ21lbnQucmFkaXVzICogMC44KSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gIFxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICBcclxuICAgIGNvbGxlY3RQb3dlclVwKHBvd2VyVXA6IFBvd2VyVXApIHtcclxuICAgICAgdGhpcy5hY3RpdmVQb3dlclVwcy5zZXQocG93ZXJVcC50eXBlLCBEYXRlLm5vdygpICsgcG93ZXJVcC5kdXJhdGlvbilcclxuICAgICAgcG93ZXJVcC5hcHBseUVmZmVjdCh0aGlzKVxyXG4gICAgICBBdWRpb1N5c3RlbS5nZXRJbnN0YW5jZSgpLnBsYXlTb3VuZCgncG93ZXJ1cCcpXHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gICJdLCJuYW1lcyI6WyJBdWRpb1N5c3RlbSIsIlNuYWtlIiwidXBkYXRlIiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJ2ZWxvY2l0eSIsIngiLCJNYXRoIiwiY29zIiwiYW5nbGUiLCJzcGVlZCIsInkiLCJzaW4iLCJoZWFkIiwic2VnbWVudHMiLCJuZXdYIiwibmV3WSIsIndyYXBwZWRYIiwid3JhcHBlZFkiLCJoaXN0b3J5IiwidW5zaGlmdCIsInNsaWNlIiwiaSIsImxlbmd0aCIsInNlZ21lbnQiLCJoaXN0b3J5UG9zIiwiZHJhdyIsImN0eCIsInNhdmUiLCJpc0ludnVsbmVyYWJsZSIsInNoYWRvd0NvbG9yIiwic2hhZG93Qmx1ciIsImlzR2hvc3QiLCJnbG9iYWxBbHBoYSIsImJlZ2luUGF0aCIsImFyYyIsInJhZGl1cyIsIlBJIiwiZmlsbFN0eWxlIiwiY29sb3IiLCJmaWxsIiwiaGVhZENvbG9yIiwiZXllT2Zmc2V0IiwiZXllUmFkaXVzIiwibGVmdEV5ZVgiLCJsZWZ0RXllWSIsInJpZ2h0RXllWCIsInJpZ2h0RXllWSIsInJlc3RvcmUiLCJ0dXJuTGVmdCIsInR1cm5pbmdTcGVlZCIsImNvbnNvbGUiLCJsb2ciLCJuZXdBbmdsZSIsInR1cm5SaWdodCIsImJvb3N0IiwiYmFzZVNwZWVkIiwibm9ybWFsU3BlZWQiLCJncm93IiwiYW1vdW50IiwidGFyZ2V0TGVuZ3RoIiwibGFzdEluZGV4IiwiaGlzdG9yeUluZGV4IiwibWluIiwicG9zaXRpb24iLCJwdXNoIiwiZ2V0SGVhZCIsImNoZWNrU2VsZkNvbGxpc2lvbiIsImRpc3RhbmNlIiwiaHlwb3QiLCJjaGVja0NvbGxpc2lvbldpdGhQb2ludCIsInBvaW50IiwiY29sbGVjdFBvd2VyVXAiLCJwb3dlclVwIiwiYWN0aXZlUG93ZXJVcHMiLCJzZXQiLCJ0eXBlIiwiRGF0ZSIsIm5vdyIsImR1cmF0aW9uIiwiYXBwbHlFZmZlY3QiLCJnZXRJbnN0YW5jZSIsInBsYXlTb3VuZCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIk1hcCIsImluaXRpYWxBbmdsZSIsImluaXRpYWxMZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/snake.tsx\n"));

/***/ })

});