"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/ai-snake.tsx":
/*!****************************!*\
  !*** ./utils/ai-snake.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISnake: function() { return /* binding */ AISnake; }\n/* harmony export */ });\n/* harmony import */ var _snake__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./snake */ \"(app-pages-browser)/./utils/snake.tsx\");\n\nclass AISnake extends _snake__WEBPACK_IMPORTED_MODULE_0__.Snake {\n    updateAI(food, playerSnake, otherSnakes, canvasWidth, canvasHeight) {\n        // Find closest food\n        let closestFood = food[0];\n        let closestDistance = Infinity;\n        for (const f of food){\n            const distance = Math.hypot(this.getHead().x - f.position.x, this.getHead().y - f.position.y);\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestFood = f;\n            }\n        }\n        if (closestFood) {\n            // Calculate angle to food\n            const dx = closestFood.position.x - this.getHead().x;\n            const dy = closestFood.position.y - this.getHead().y;\n            const targetAngle = Math.atan2(dy, dx);\n            // Turn towards food\n            const angleDiff = targetAngle - this.angle;\n            const normalizedDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));\n            if (normalizedDiff > 0.1) {\n                this.turnRight();\n            } else if (normalizedDiff < -0.1) {\n                this.turnLeft();\n            }\n            // Boost if far from food\n            if (closestDistance > 100) {\n                this.boost();\n            } else {\n                this.normalSpeed();\n            }\n        }\n    }\n    passiveBehavior(food, playerSnake, otherSnakes) {\n        // Find nearest food while avoiding others\n        const nearestFood = this.findNearestFood(food);\n        if (nearestFood) {\n            this.targetAngle = Math.atan2(nearestFood.position.y - this.getHead().y, nearestFood.position.x - this.getHead().x);\n        }\n        // Avoid collisions\n        this.avoidCollisions(playerSnake, otherSnakes);\n    }\n    aggressiveBehavior(playerSnake, otherSnakes) {\n        if (playerSnake) {\n            // Chase player\n            const playerHead = playerSnake.getHead();\n            this.targetAngle = Math.atan2(playerHead.y - this.getHead().y, playerHead.x - this.getHead().x);\n        }\n    }\n    territorialBehavior(food, playerSnake, canvasWidth, canvasHeight) {\n        if (!this.territoryCenter) {\n            this.territoryCenter = {\n                x: canvasWidth / 2,\n                y: canvasHeight / 2\n            };\n        }\n        // Stay in territory while collecting food\n        const head = this.getHead();\n        const distanceToCenter = Math.hypot(head.x - this.territoryCenter.x, head.y - this.territoryCenter.y);\n        if (distanceToCenter > 150) {\n            // Return to territory\n            this.targetAngle = Math.atan2(this.territoryCenter.y - head.y, this.territoryCenter.x - head.x);\n        } else {\n            // Look for food within territory\n            const nearbyFood = food.filter((f)=>Math.hypot(f.position.x - this.territoryCenter.x, f.position.y - this.territoryCenter.y) < 150);\n            if (nearbyFood.length > 0) {\n                const nearest = this.findNearestFood(nearbyFood);\n                if (nearest) {\n                    this.targetAngle = Math.atan2(nearest.position.y - head.y, nearest.position.x - head.x);\n                }\n            }\n        }\n    }\n    findNearestFood(food) {\n        let nearest = null;\n        let minDistance = Infinity;\n        const head = this.getHead();\n        for (const f of food){\n            const distance = Math.hypot(f.position.x - head.x, f.position.y - head.y);\n            if (distance < minDistance) {\n                minDistance = distance;\n                nearest = f;\n            }\n        }\n        return nearest;\n    }\n    avoidCollisions(playerSnake, otherSnakes) {\n        const head = this.getHead();\n        const avoidanceRadius = 100;\n        let needsToAvoid = false;\n        // Check player snake\n        if (playerSnake) {\n            const playerHead = playerSnake.getHead();\n            if (Math.hypot(playerHead.x - head.x, playerHead.y - head.y) < avoidanceRadius) {\n                this.targetAngle = Math.atan2(head.y - playerHead.y, head.x - playerHead.x);\n                needsToAvoid = true;\n            }\n        }\n        // Check other AI snakes\n        if (!needsToAvoid) {\n            for (const snake of otherSnakes){\n                const otherHead = snake.getHead();\n                if (Math.hypot(otherHead.x - head.x, otherHead.y - head.y) < avoidanceRadius) {\n                    this.targetAngle = Math.atan2(head.y - otherHead.y, head.x - otherHead.x);\n                    needsToAvoid = true;\n                    break;\n                }\n            }\n        }\n    }\n    turnTowardsTarget() {\n        const angleDiff = this.targetAngle - this.angle;\n        const normalizedDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));\n        if (normalizedDiff > 0.1) {\n            this.turnRight();\n        } else if (normalizedDiff < -0.1) {\n            this.turnLeft();\n        }\n    }\n    checkCollisionWith(point) {\n        return super.checkCollisionWithPoint(point);\n    }\n    constructor(options){\n        super(options);\n        this.targetAngle = 0;\n        this.behavior = options.behavior;\n        if (this.behavior === \"territorial\") {\n            this.territoryCenter = {\n                x: options.x,\n                y: options.y\n            };\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL2FpLXNuYWtlLnRzeCIsIm1hcHBpbmdzIjoiOzs7OztBQUFnQztBQWN6QixNQUFNQyxnQkFBZ0JELHlDQUFLQTtJQWNoQ0UsU0FDRUMsSUFBWSxFQUNaQyxXQUF5QixFQUN6QkMsV0FBc0IsRUFDdEJDLFdBQW1CLEVBQ25CQyxZQUFvQixFQUNkO1FBQ04sb0JBQW9CO1FBQ3BCLElBQUlDLGNBQWNMLElBQUksQ0FBQyxFQUFFO1FBQ3pCLElBQUlNLGtCQUFrQkM7UUFFdEIsS0FBSyxNQUFNQyxLQUFLUixLQUFNO1lBQ3BCLE1BQU1TLFdBQVdDLEtBQUtDLEtBQUssQ0FDekIsSUFBSSxDQUFDQyxPQUFPLEdBQUdDLENBQUMsR0FBR0wsRUFBRU0sUUFBUSxDQUFDRCxDQUFDLEVBQy9CLElBQUksQ0FBQ0QsT0FBTyxHQUFHRyxDQUFDLEdBQUdQLEVBQUVNLFFBQVEsQ0FBQ0MsQ0FBQztZQUVqQyxJQUFJTixXQUFXSCxpQkFBaUI7Z0JBQzlCQSxrQkFBa0JHO2dCQUNsQkosY0FBY0c7WUFDaEI7UUFDRjtRQUVBLElBQUlILGFBQWE7WUFDZiwwQkFBMEI7WUFDMUIsTUFBTVcsS0FBS1gsWUFBWVMsUUFBUSxDQUFDRCxDQUFDLEdBQUcsSUFBSSxDQUFDRCxPQUFPLEdBQUdDLENBQUM7WUFDcEQsTUFBTUksS0FBS1osWUFBWVMsUUFBUSxDQUFDQyxDQUFDLEdBQUcsSUFBSSxDQUFDSCxPQUFPLEdBQUdHLENBQUM7WUFDcEQsTUFBTUcsY0FBY1IsS0FBS1MsS0FBSyxDQUFDRixJQUFJRDtZQUVuQyxvQkFBb0I7WUFDcEIsTUFBTUksWUFBWUYsY0FBYyxJQUFJLENBQUNHLEtBQUs7WUFDMUMsTUFBTUMsaUJBQWlCWixLQUFLUyxLQUFLLENBQUNULEtBQUthLEdBQUcsQ0FBQ0gsWUFBWVYsS0FBS2MsR0FBRyxDQUFDSjtZQUVoRSxJQUFJRSxpQkFBaUIsS0FBSztnQkFDeEIsSUFBSSxDQUFDRyxTQUFTO1lBQ2hCLE9BQU8sSUFB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QyxDQUFDLEdBQUdzQixLQUFLdEIsQ0FBQyxJQUFJNkIsaUJBQWlCO29CQUM1RSxJQUFJLENBQUMxQixXQUFXLEdBQUdSLEtBQUtTLEtBQUssQ0FDM0JrQixLQUFLdEIsQ0FBQyxHQUFHZ0MsVUFBVWhDLENBQUMsRUFDcEJzQixLQUFLeEIsQ0FBQyxHQUFHa0MsVUFBVWxDLENBQUM7b0JBRXRCZ0MsZUFBZTtvQkFDZjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVRRyxvQkFBMEI7UUFDaEMsTUFBTTVCLFlBQVksSUFBSSxDQUFDRixXQUFXLEdBQUcsSUFBSSxDQUFDRyxLQUFLO1FBQy9DLE1BQU1DLGlCQUFpQlosS0FBS1MsS0FBSyxDQUFDVCxLQUFLYSxHQUFHLENBQUNILFlBQVlWLEtBQUtjLEdBQUcsQ0FBQ0o7UUFFaEUsSUFBSUUsaUJBQWlCLEtBQUs7WUFDeEIsSUFBSSxDQUFDRyxTQUFTO1FBQ2hCLE9BQU8sSUFBSUgsaUJBQWlCLENBQUMsS0FBSztZQUNoQyxJQUFJLENBQUNJLFFBQVE7UUFDZjtJQUNGO0lBRUF1QixtQkFBbUJDLEtBQStDLEVBQVc7UUFDM0UsT0FBTyxLQUFLLENBQUNDLHdCQUF3QkQ7SUFDdkM7SUEzTUFFLFlBQVlDLE9BQXVCLENBQUU7UUFDbkMsS0FBSyxDQUFDQTthQUpBbkMsY0FBc0I7UUFLNUIsSUFBSSxDQUFDb0MsUUFBUSxHQUFHRCxRQUFRQyxRQUFRO1FBRWhDLElBQUksSUFBSSxDQUFDQSxRQUFRLEtBQUssZUFBZTtZQUNuQyxJQUFJLENBQUNsQixlQUFlLEdBQUc7Z0JBQUV2QixHQUFHd0MsUUFBUXhDLENBQUM7Z0JBQUVFLEdBQUdzQyxRQUFRdEMsQ0FBQztZQUFDO1FBQ3REO0lBQ0Y7QUFxTUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvYWktc25ha2UudHN4PzkwYzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU25ha2UgfSBmcm9tICcuL3NuYWtlJztcclxuaW1wb3J0IHsgRm9vZCB9IGZyb20gJy4vZm9vZCc7XHJcblxyXG5pbnRlcmZhY2UgQUlTbmFrZU9wdGlvbnMge1xyXG4gIHg6IG51bWJlcjtcclxuICB5OiBudW1iZXI7XHJcbiAgY29sb3I6IHN0cmluZztcclxuICBoZWFkQ29sb3I6IHN0cmluZztcclxuICBpbml0aWFsTGVuZ3RoOiBudW1iZXI7XHJcbiAgaW5pdGlhbEFuZ2xlOiBudW1iZXI7XHJcbiAgc3BlZWQ6IG51bWJlcjtcclxuICBiZWhhdmlvcjogJ3Bhc3NpdmUnIHwgJ2FnZ3Jlc3NpdmUnIHwgJ3RlcnJpdG9yaWFsJztcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEFJU25ha2UgZXh0ZW5kcyBTbmFrZSB7XHJcbiAgcHJpdmF0ZSBiZWhhdmlvcjogJ3Bhc3NpdmUnIHwgJ2FnZ3Jlc3NpdmUnIHwgJ3RlcnJpdG9yaWFsJztcclxuICBwcml2YXRlIHRhcmdldEFuZ2xlOiBudW1iZXIgPSAwO1xyXG4gIHByaXZhdGUgdGVycml0b3J5Q2VudGVyPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xyXG5cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBSVNuYWtlT3B0aW9ucykge1xyXG4gICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICB0aGlzLmJlaGF2aW9yID0gb3B0aW9ucy5iZWhhdmlvcjtcclxuICAgIFxyXG4gICAgaWYgKHRoaXMuYmVoYXZpb3IgPT09ICd0ZXJyaXRvcmlhbCcpIHtcclxuICAgICAgdGhpcy50ZXJyaXRvcnlDZW50ZXIgPSB7IHg6IG9wdGlvbnMueCwgeTogb3B0aW9ucy55IH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVBSShcclxuICAgIGZvb2Q6IEZvb2RbXSxcclxuICAgIHBsYXllclNuYWtlOiBTbmFrZSB8IG51bGwsXHJcbiAgICBvdGhlclNuYWtlczogQUlTbmFrZVtdLFxyXG4gICAgY2FudmFzV2lkdGg6IG51bWJlcixcclxuICAgIGNhbnZhc0hlaWdodDogbnVtYmVyXHJcbiAgKTogdm9pZCB7XHJcbiAgICAvLyBGaW5kIGNsb3Nlc3QgZm9vZFxyXG4gICAgbGV0IGNsb3Nlc3RGb29kID0gZm9vZFswXTtcclxuICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGYgb2YgZm9vZCkge1xyXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguaHlwb3QoXHJcbiAgICAgICAgdGhpcy5nZXRIZWFkKCkueCAtIGYucG9zaXRpb24ueCxcclxuICAgICAgICB0aGlzLmdldEhlYWQoKS55IC0gZi5wb3NpdGlvbi55XHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChkaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSkge1xyXG4gICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgIGNsb3Nlc3RGb29kID0gZjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChjbG9zZXN0Rm9vZCkge1xyXG4gICAgICAvLyBDYWxjdWxhdGUgYW5nbGUgdG8gZm9vZFxyXG4gICAgICBjb25zdCBkeCA9IGNsb3Nlc3RGb29kLnBvc2l0aW9uLnggLSB0aGlzLmdldEhlYWQoKS54O1xyXG4gICAgICBjb25zdCBkeSA9IGNsb3Nlc3RGb29kLnBvc2l0aW9uLnkgLSB0aGlzLmdldEhlYWQoKS55O1xyXG4gICAgICBjb25zdCB0YXJnZXRBbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTtcclxuXHJcbiAgICAgIC8vIFR1cm4gdG93YXJkcyBmb29kXHJcbiAgICAgIGNvbnN0IGFuZ2xlRGlmZiA9IHRhcmdldEFuZ2xlIC0gdGhpcy5hbmdsZTtcclxuICAgICAgY29uc3Qgbm9ybWFsaXplZERpZmYgPSBNYXRoLmF0YW4yKE1hdGguc2luKGFuZ2xlRGlmZiksIE1hdGguY29zKGFuZ2xlRGlmZikpO1xyXG5cclxuICAgICAgaWYgKG5vcm1hbGl6ZWREaWZmID4gMC4xKSB7XHJcbiAgICAgICAgdGhpcy50dXJuUmlnaHQoKTtcclxuICAgICAgfSBlbHNlIGlmIChub3JtYWxpemVkRGlmZiA8IC0wLjEpIHtcclxuICAgICAgICB0aGlzLnR1cm5MZWZ0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEJvb3N0IGlmIGZhciBmcm9tIGZvb2RcclxuICAgICAgaWYgKGNsb3Nlc3REaXN0YW5jZSA+IDEwMCkge1xyXG4gICAgICAgIHRoaXMuYm9vc3QoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm5vcm1hbFNwZWVkKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgcGFzc2l2ZUJlaGF2aW9yKFxyXG4gICAgZm9vZDogRm9vZFtdLFxyXG4gICAgcGxheWVyU25ha2U6IFNuYWtlIHwgbnVsbCxcclxuICAgIG90aGVyU25ha2VzOiBBSVNuYWtlW11cclxuICApOiB2b2lkIHtcclxuICAgIC8vIEZpbmQgbmVhcmVzdCBmb29kIHdoaWxlIGF2b2lkaW5nIG90aGVyc1xyXG4gICAgY29uc3QgbmVhcmVzdEZvb2QgPSB0aGlzLmZpbmROZWFyZXN0Rm9vZChmb29kKTtcclxuICAgIGlmIChuZWFyZXN0Rm9vZCkge1xyXG4gICAgICB0aGlzLnRhcmdldEFuZ2xlID0gTWF0aC5hdGFuMihcclxuICAgICAgICBuZWFyZXN0Rm9vZC5wb3NpdGlvbi55IC0gdGhpcy5nZXRIZWFkKCkueSxcclxuICAgICAgICBuZWFyZXN0Rm9vZC5wb3NpdGlvbi54IC0gdGhpcy5nZXRIZWFkKCkueFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEF2b2lkIGNvbGxpc2lvbnNcclxuICAgIHRoaXMuYXZvaWRDb2xsaXNpb25zKHBsYXllclNuYWtlLCBvdGhlclNuYWtlcyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFnZ3Jlc3NpdmVCZWhhdmlvcihcclxuICAgIHBsYXllclNuYWtlOiBTbmFrZSB8IG51bGwsXHJcbiAgICBvdGhlclNuYWtlczogQUlTbmFrZVtdXHJcbiAgKTogdm9pZCB7XHJcbiAgICBpZiAocGxheWVyU25ha2UpIHtcclxuICAgICAgLy8gQ2hhc2UgcGxheWVyXHJcbiAgICAgIGNvbnN0IHBsYXllckhlYWQgPSBwbGF5ZXJTbmFrZS5nZXRIZWFkKCk7XHJcbiAgICAgIHRoaXMudGFyZ2V0QW5nbGUgPSBNYXRoLmF0YW4yKFxyXG4gICAgICAgIHBsYXllckhlYWQueSAtIHRoaXMuZ2V0SGVhZCgpLnksXHJcbiAgICAgICAgcGxheWVySGVhZC54IC0gdGhpcy5nZXRIZWFkKCkueFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB0ZXJyaXRvcmlhbEJlaGF2aW9yKFxyXG4gICAgZm9vZDogRm9vZFtdLFxyXG4gICAgcGxheWVyU25ha2U6IFNuYWtlIHwgbnVsbCxcclxuICAgIGNhbnZhc1dpZHRoOiBudW1iZXIsXHJcbiAgICBjYW52YXNIZWlnaHQ6IG51bWJlclxyXG4gICk6IHZvaWQge1xyXG4gICAgaWYgKCF0aGlzLnRlcnJpdG9yeUNlbnRlcikge1xyXG4gICAgICB0aGlzLnRlcnJpdG9yeUNlbnRlciA9IHtcclxuICAgICAgICB4OiBjYW52YXNXaWR0aCAvIDIsXHJcbiAgICAgICAgeTogY2FudmFzSGVpZ2h0IC8gMlxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXkgaW4gdGVycml0b3J5IHdoaWxlIGNvbGxlY3RpbmcgZm9vZFxyXG4gICAgY29uc3QgaGVhZCA9IHRoaXMuZ2V0SGVhZCgpO1xyXG4gICAgY29uc3QgZGlzdGFuY2VUb0NlbnRlciA9IE1hdGguaHlwb3QoXHJcbiAgICAgIGhlYWQueCAtIHRoaXMudGVycml0b3J5Q2VudGVyLngsXHJcbiAgICAgIGhlYWQueSAtIHRoaXMudGVycml0b3J5Q2VudGVyLnlcclxuICAgICk7XHJcblxyXG4gICAgaWYgKGRpc3RhbmNlVG9DZW50ZXIgPiAxNTApIHtcclxuICAgICAgLy8gUmV0dXJuIHRvIHRlcnJpdG9yeVxyXG4gICAgICB0aGlzLnRhcmdldEFuZ2xlID0gTWF0aC5hdGFuMihcclxuICAgICAgICB0aGlzLnRlcnJpdG9yeUNlbnRlci55IC0gaGVhZC55LFxyXG4gICAgICAgIHRoaXMudGVycml0b3J5Q2VudGVyLnggLSBoZWFkLnhcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIExvb2sgZm9yIGZvb2Qgd2l0aGluIHRlcnJpdG9yeVxyXG4gICAgICBjb25zdCBuZWFyYnlGb29kID0gZm9vZC5maWx0ZXIoZiA9PiBcclxuICAgICAgICBNYXRoLmh5cG90KFxyXG4gICAgICAgICAgZi5wb3NpdGlvbi54IC0gdGhpcy50ZXJyaXRvcnlDZW50ZXIhLngsXHJcbiAgICAgICAgICBmLnBvc2l0aW9uLnkgLSB0aGlzLnRlcnJpdG9yeUNlbnRlciEueVxyXG4gICAgICAgICkgPCAxNTBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmIChuZWFyYnlGb29kLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBuZWFyZXN0ID0gdGhpcy5maW5kTmVhcmVzdEZvb2QobmVhcmJ5Rm9vZCk7XHJcbiAgICAgICAgaWYgKG5lYXJlc3QpIHtcclxuICAgICAgICAgIHRoaXMudGFyZ2V0QW5nbGUgPSBNYXRoLmF0YW4yKFxyXG4gICAgICAgICAgICBuZWFyZXN0LnBvc2l0aW9uLnkgLSBoZWFkLnksXHJcbiAgICAgICAgICAgIG5lYXJlc3QucG9zaXRpb24ueCAtIGhlYWQueFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZmluZE5lYXJlc3RGb29kKGZvb2Q6IEZvb2RbXSk6IEZvb2QgfCBudWxsIHtcclxuICAgIGxldCBuZWFyZXN0OiBGb29kIHwgbnVsbCA9IG51bGw7XHJcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcclxuICAgIGNvbnN0IGhlYWQgPSB0aGlzLmdldEhlYWQoKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGYgb2YgZm9vZCkge1xyXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguaHlwb3QoXHJcbiAgICAgICAgZi5wb3NpdGlvbi54IC0gaGVhZC54LFxyXG4gICAgICAgIGYucG9zaXRpb24ueSAtIGhlYWQueVxyXG4gICAgICApO1xyXG4gICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xyXG4gICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgbmVhcmVzdCA9IGY7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmVhcmVzdDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXZvaWRDb2xsaXNpb25zKFxyXG4gICAgcGxheWVyU25ha2U6IFNuYWtlIHwgbnVsbCxcclxuICAgIG90aGVyU25ha2VzOiBBSVNuYWtlW11cclxuICApOiB2b2lkIHtcclxuICAgIGNvbnN0IGhlYWQgPSB0aGlzLmdldEhlYWQoKTtcclxuICAgIGNvbnN0IGF2b2lkYW5jZVJhZGl1cyA9IDEwMDtcclxuICAgIGxldCBuZWVkc1RvQXZvaWQgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBDaGVjayBwbGF5ZXIgc25ha2VcclxuICAgIGlmIChwbGF5ZXJTbmFrZSkge1xyXG4gICAgICBjb25zdCBwbGF5ZXJIZWFkID0gcGxheWVyU25ha2UuZ2V0SGVhZCgpO1xyXG4gICAgICBpZiAoTWF0aC5oeXBvdChwbGF5ZXJIZWFkLnggLSBoZWFkLngsIHBsYXllckhlYWQueSAtIGhlYWQueSkgPCBhdm9pZGFuY2VSYWRpdXMpIHtcclxuICAgICAgICB0aGlzLnRhcmdldEFuZ2xlID0gTWF0aC5hdGFuMihcclxuICAgICAgICAgIGhlYWQueSAtIHBsYXllckhlYWQueSxcclxuICAgICAgICAgIGhlYWQueCAtIHBsYXllckhlYWQueFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgbmVlZHNUb0F2b2lkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIG90aGVyIEFJIHNuYWtlc1xyXG4gICAgaWYgKCFuZWVkc1RvQXZvaWQpIHtcclxuICAgICAgZm9yIChjb25zdCBzbmFrZSBvZiBvdGhlclNuYWtlcykge1xyXG4gICAgICAgIGNvbnN0IG90aGVySGVhZCA9IHNuYWtlLmdldEhlYWQoKTtcclxuICAgICAgICBpZiAoTWF0aC5oeXBvdChvdGhlckhlYWQueCAtIGhlYWQueCwgb3RoZXJIZWFkLnkgLSBoZWFkLnkpIDwgYXZvaWRhbmNlUmFkaXVzKSB7XHJcbiAgICAgICAgICB0aGlzLnRhcmdldEFuZ2xlID0gTWF0aC5hdGFuMihcclxuICAgICAgICAgICAgaGVhZC55IC0gb3RoZXJIZWFkLnksXHJcbiAgICAgICAgICAgIGhlYWQueCAtIG90aGVySGVhZC54XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgbmVlZHNUb0F2b2lkID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB0dXJuVG93YXJkc1RhcmdldCgpOiB2b2lkIHtcclxuICAgIGNvbnN0IGFuZ2xlRGlmZiA9IHRoaXMudGFyZ2V0QW5nbGUgLSB0aGlzLmFuZ2xlO1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZERpZmYgPSBNYXRoLmF0YW4yKE1hdGguc2luKGFuZ2xlRGlmZiksIE1hdGguY29zKGFuZ2xlRGlmZikpO1xyXG4gICAgXHJcbiAgICBpZiAobm9ybWFsaXplZERpZmYgPiAwLjEpIHtcclxuICAgICAgdGhpcy50dXJuUmlnaHQoKTtcclxuICAgIH0gZWxzZSBpZiAobm9ybWFsaXplZERpZmYgPCAtMC4xKSB7XHJcbiAgICAgIHRoaXMudHVybkxlZnQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNoZWNrQ29sbGlzaW9uV2l0aChwb2ludDogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgcmFkaXVzOiBudW1iZXIgfSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHN1cGVyLmNoZWNrQ29sbGlzaW9uV2l0aFBvaW50KHBvaW50KTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbIlNuYWtlIiwiQUlTbmFrZSIsInVwZGF0ZUFJIiwiZm9vZCIsInBsYXllclNuYWtlIiwib3RoZXJTbmFrZXMiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsImNsb3Nlc3RGb29kIiwiY2xvc2VzdERpc3RhbmNlIiwiSW5maW5pdHkiLCJmIiwiZGlzdGFuY2UiLCJNYXRoIiwiaHlwb3QiLCJnZXRIZWFkIiwieCIsInBvc2l0aW9uIiwieSIsImR4IiwiZHkiLCJ0YXJnZXRBbmdsZSIsImF0YW4yIiwiYW5nbGVEaWZmIiwiYW5nbGUiLCJub3JtYWxpemVkRGlmZiIsInNpbiIsImNvcyIsInR1cm5SaWdodCIsInR1cm5MZWZ0IiwiYm9vc3QiLCJub3JtYWxTcGVlZCIsInBhc3NpdmVCZWhhdmlvciIsIm5lYXJlc3RGb29kIiwiZmluZE5lYXJlc3RGb29kIiwiYXZvaWRDb2xsaXNpb25zIiwiYWdncmVzc2l2ZUJlaGF2aW9yIiwicGxheWVySGVhZCIsInRlcnJpdG9yaWFsQmVoYXZpb3IiLCJ0ZXJyaXRvcnlDZW50ZXIiLCJoZWFkIiwiZGlzdGFuY2VUb0NlbnRlciIsIm5lYXJieUZvb2QiLCJmaWx0ZXIiLCJsZW5ndGgiLCJuZWFyZXN0IiwibWluRGlzdGFuY2UiLCJhdm9pZGFuY2VSYWRpdXMiLCJuZWVkc1RvQXZvaWQiLCJzbmFrZSIsIm90aGVySGVhZCIsInR1cm5Ub3dhcmRzVGFyZ2V0IiwiY2hlY2tDb2xsaXNpb25XaXRoIiwicG9pbnQiLCJjaGVja0NvbGxpc2lvbldpdGhQb2ludCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImJlaGF2aW9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/ai-snake.tsx\n"));

/***/ })

});