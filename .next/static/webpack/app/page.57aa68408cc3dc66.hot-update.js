"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/snake.tsx":
/*!*************************!*\
  !*** ./utils/snake.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Snake: function() { return /* binding */ Snake; }\n/* harmony export */ });\n/* harmony import */ var _audio_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audio-system */ \"(app-pages-browser)/./utils/audio-system.tsx\");\n\nclass Snake {\n    update(canvasWidth, canvasHeight) {\n        // Update velocity based on current angle\n        this.velocity = {\n            x: Math.cos(this.angle) * this.speed,\n            y: Math.sin(this.angle) * this.speed\n        };\n        // Move head\n        const head = this.segments[0];\n        const newX = head.x + this.velocity.x;\n        const newY = head.y + this.velocity.y;\n        // Handle wrapping around edges\n        let wrappedX = newX;\n        let wrappedY = newY;\n        if (wrappedX < 0) wrappedX = canvasWidth;\n        if (wrappedX > canvasWidth) wrappedX = 0;\n        if (wrappedY < 0) wrappedY = canvasHeight;\n        if (wrappedY > canvasHeight) wrappedY = 0;\n        // Update head position\n        head.x = wrappedX;\n        head.y = wrappedY;\n        // Add new position to history\n        this.history.unshift({\n            x: wrappedX,\n            y: wrappedY\n        });\n        this.history = this.history.slice(0, 1000); // Keep last 1000 positions\n        // Update body segments\n        const spacing = 20; // Distance between segments\n        for(let i = 1; i < this.segments.length; i++){\n            const segment = this.segments[i];\n            const historyIndex = i * 5; // Use history to create smooth following\n            if (this.history[historyIndex]) {\n                segment.x = this.history[historyIndex].x;\n                segment.y = this.history[historyIndex].y;\n            }\n        }\n    }\n    draw(ctx) {\n        ctx.save();\n        // Apply visual effects based on power-ups\n        if (this.isInvulnerable) {\n            ctx.shadowColor = \"#f0f\";\n            ctx.shadowBlur = 20;\n        }\n        if (this.isGhost) {\n            ctx.globalAlpha = 0.6;\n        }\n        // Draw body segments\n        for(let i = this.segments.length - 1; i > 0; i--){\n            const segment = this.segments[i];\n            ctx.beginPath();\n            ctx.arc(segment.x, segment.y, segment.radius, 0, Math.PI * 2);\n            ctx.fillStyle = this.color;\n            ctx.fill();\n            // Add glow effect\n            ctx.shadowColor = this.color;\n            ctx.shadowBlur = 10;\n            ctx.fill();\n            ctx.shadowBlur = 0;\n        }\n        // Draw head\n        const head = this.segments[0];\n        ctx.beginPath();\n        ctx.arc(head.x, head.y, head.radius, 0, Math.PI * 2);\n        ctx.fillStyle = this.headColor;\n        ctx.fill();\n        // Add glow effect to head\n        ctx.shadowColor = this.headColor;\n        ctx.shadowBlur = 15;\n        ctx.fill();\n        ctx.shadowBlur = 0;\n        // Draw eyes\n        const eyeOffset = 3;\n        const eyeRadius = 2;\n        // Calculate eye positions based on angle\n        const leftEyeX = head.x + Math.cos(this.angle - 0.3) * eyeOffset;\n        const leftEyeY = head.y + Math.sin(this.angle - 0.3) * eyeOffset;\n        const rightEyeX = head.x + Math.cos(this.angle + 0.3) * eyeOffset;\n        const rightEyeY = head.y + Math.sin(this.angle + 0.3) * eyeOffset;\n        // Draw left eye\n        ctx.beginPath();\n        ctx.arc(leftEyeX, leftEyeY, eyeRadius, 0, Math.PI * 2);\n        ctx.fillStyle = \"#fff\";\n        ctx.fill();\n        // Draw right eye\n        ctx.beginPath();\n        ctx.arc(rightEyeX, rightEyeY, eyeRadius, 0, Math.PI * 2);\n        ctx.fillStyle = \"#fff\";\n        ctx.fill();\n        ctx.restore();\n    }\n    turnLeft() {\n        this.angle -= this.turningSpeed;\n        console.log(\"Turning left, new angle:\", this.angle);\n    }\n    turnRight() {\n        this.angle += this.turningSpeed;\n        console.log(\"Turning right, new angle:\", this.angle);\n    }\n    boost() {\n        this.speed = this.baseSpeed * 2;\n    }\n    normalSpeed() {\n        this.speed = this.baseSpeed;\n    }\n    grow(amount) {\n        // Increase target length\n        this.targetLength += amount;\n        // Add segments if needed\n        while(this.segments.length < this.targetLength){\n            const lastIndex = this.segments.length - 1;\n            const historyIndex = Math.min(lastIndex * 5, this.history.length - 1);\n            // Get position from history\n            const position = this.history[historyIndex];\n            // Add new segment\n            this.segments.push({\n                x: position.x,\n                y: position.y,\n                radius: 8 - Math.min(3, this.segments.length * 0.1)\n            });\n        }\n    }\n    getHead() {\n        return this.segments[0];\n    }\n    checkSelfCollision() {\n        const head = this.getHead();\n        // Skip the first few segments to prevent false collisions\n        for(let i = 10; i < this.segments.length; i++){\n            const segment = this.segments[i];\n            const distance = Math.hypot(head.x - segment.x, head.y - segment.y);\n            if (distance < head.radius + segment.radius * 0.5) {\n                return true;\n            }\n        }\n        return false;\n    }\n    checkCollisionWithPoint(point) {\n        // Skip the head\n        for(let i = 1; i < this.segments.length; i++){\n            const segment = this.segments[i];\n            const distance = Math.hypot(point.x - segment.x, point.y - segment.y);\n            if (distance < point.radius + segment.radius * 0.8) {\n                return true;\n            }\n        }\n        return false;\n    }\n    collectPowerUp(powerUp) {\n        this.activePowerUps.set(powerUp.type, Date.now() + powerUp.duration);\n        powerUp.applyEffect(this);\n        _audio_system__WEBPACK_IMPORTED_MODULE_0__.AudioSystem.getInstance().playSound(\"powerup\");\n    }\n    constructor(options){\n        this.segments = [];\n        this.velocity = {\n            x: 0,\n            y: 0\n        };\n        this.turningSpeed = 0.05;\n        this.history = [];\n        this.isInvulnerable = false;\n        this.isGhost = false;\n        this.activePowerUps = new Map();\n        this.angle = options.initialAngle;\n        this.speed = options.speed;\n        this.baseSpeed = options.speed;\n        this.color = options.color;\n        this.headColor = options.headColor;\n        this.targetLength = options.initialLength;\n        // Initialize first segment (head)\n        this.segments.push({\n            x: options.x,\n            y: options.y,\n            radius: 15 // Increased head radius for better collision detection\n        });\n        // Add initial body segments\n        for(let i = 1; i < options.initialLength; i++){\n            this.segments.push({\n                x: options.x - i * Math.cos(options.initialAngle) * 20,\n                y: options.y - i * Math.sin(options.initialAngle) * 20,\n                radius: 12 // Slightly larger body segments\n            });\n        }\n        // Initialize history with head position\n        for(let i = 0; i < 1000; i++){\n            this.history.push({\n                x: options.x,\n                y: options.y\n            });\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxHQUFHaUIsSUFBSWhCLEtBQUtDLEdBQUcsQ0FBQzJFLFFBQVFFLFlBQVksSUFBSTtnQkFDcEQxRSxHQUFHd0UsUUFBUXhFLENBQUMsR0FBR1ksSUFBSWhCLEtBQUtLLEdBQUcsQ0FBQ3VFLFFBQVFFLFlBQVksSUFBSTtnQkFDcERoRCxRQUFRLEdBQUksZ0NBQWdDO1lBQzlDO1FBQ0Y7UUFFQSx3Q0FBd0M7UUFDeEMsSUFBSyxJQUFJZCxJQUFJLEdBQUdBLElBQUksTUFBTUEsSUFBSztZQUM3QixJQUFJLENBQUNKLE9BQU8sQ0FBQzZDLElBQUksQ0FBQztnQkFBRTFELEdBQUc2RSxRQUFRN0UsQ0FBQztnQkFBRUssR0FBR3dFLFFBQVF4RSxDQUFDO1lBQUM7UUFDakQ7SUFDRjtBQTZMRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9zbmFrZS50c3g/NjUwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb3dlclVwVHlwZSB9IGZyb20gJy4vcG93ZXItdXAnO1xyXG5pbXBvcnQgeyBBdWRpb1N5c3RlbSB9IGZyb20gJy4vYXVkaW8tc3lzdGVtJztcclxuXHJcbmludGVyZmFjZSBQb3dlclVwIHtcclxuICB0eXBlOiBQb3dlclVwVHlwZTtcclxuICBkdXJhdGlvbjogbnVtYmVyO1xyXG4gIGFwcGx5RWZmZWN0OiAoc25ha2U6IFNuYWtlKSA9PiB2b2lkO1xyXG59XHJcblxyXG4vLyBTbmFrZSBzZWdtZW50IGludGVyZmFjZVxyXG5pbnRlcmZhY2UgU25ha2VTZWdtZW50IHtcclxuICAgIHg6IG51bWJlclxyXG4gICAgeTogbnVtYmVyXHJcbiAgICByYWRpdXM6IG51bWJlclxyXG4gIH1cclxuICBcclxuICAvLyBTbmFrZSBvcHRpb25zIGludGVyZmFjZVxyXG4gIGludGVyZmFjZSBTbmFrZU9wdGlvbnMge1xyXG4gICAgeDogbnVtYmVyXHJcbiAgICB5OiBudW1iZXJcclxuICAgIGNvbG9yOiBzdHJpbmdcclxuICAgIGhlYWRDb2xvcjogc3RyaW5nXHJcbiAgICBpbml0aWFsTGVuZ3RoOiBudW1iZXJcclxuICAgIGluaXRpYWxBbmdsZTogbnVtYmVyXHJcbiAgICBzcGVlZDogbnVtYmVyXHJcbiAgfVxyXG4gIFxyXG4gIGV4cG9ydCBjbGFzcyBTbmFrZSB7XHJcbiAgICBzZWdtZW50czogU25ha2VTZWdtZW50W10gPSBbXVxyXG4gICAgdmVsb2NpdHkgPSB7IHg6IDAsIHk6IDAgfVxyXG4gICAgYW5nbGU6IG51bWJlclxyXG4gICAgc3BlZWQ6IG51bWJlclxyXG4gICAgYmFzZVNwZWVkOiBudW1iZXJcclxuICAgIHR1cm5pbmdTcGVlZCA9IDAuMDVcclxuICAgIGNvbG9yOiBzdHJpbmdcclxuICAgIGhlYWRDb2xvcjogc3RyaW5nXHJcbiAgICB0YXJnZXRMZW5ndGg6IG51bWJlclxyXG4gICAgaGlzdG9yeTogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9W10gPSBbXVxyXG4gICAgaXNJbnZ1bG5lcmFibGU6IGJvb2xlYW4gPSBmYWxzZVxyXG4gICAgaXNHaG9zdDogYm9vbGVhbiA9IGZhbHNlXHJcbiAgICBhY3RpdmVQb3dlclVwczogTWFwPFBvd2VyVXBUeXBlLCBudW1iZXI+ID0gbmV3IE1hcCgpXHJcbiAgXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTbmFrZU9wdGlvbnMpIHtcclxuICAgICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuaW5pdGlhbEFuZ2xlXHJcbiAgICAgIHRoaXMuc3BlZWQgPSBvcHRpb25zLnNwZWVkXHJcbiAgICAgIHRoaXMuYmFzZVNwZWVkID0gb3B0aW9ucy5zcGVlZFxyXG4gICAgICB0aGlzLmNvbG9yID0gb3B0aW9ucy5jb2xvclxyXG4gICAgICB0aGlzLmhlYWRDb2xvciA9IG9wdGlvbnMuaGVhZENvbG9yXHJcbiAgICAgIHRoaXMudGFyZ2V0TGVuZ3RoID0gb3B0aW9ucy5pbml0aWFsTGVuZ3RoXHJcbiAgXHJcbiAgICAgIC8vIEluaXRpYWxpemUgZmlyc3Qgc2VnbWVudCAoaGVhZClcclxuICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICB4OiBvcHRpb25zLngsXHJcbiAgICAgICAgeTogb3B0aW9ucy55LFxyXG4gICAgICAgIHJhZGl1czogMTUgIC8vIEluY3JlYXNlZCBoZWFkIHJhZGl1cyBmb3IgYmV0dGVyIGNvbGxpc2lvbiBkZXRlY3Rpb25cclxuICAgICAgfSlcclxuICBcclxuICAgICAgLy8gQWRkIGluaXRpYWwgYm9keSBzZWdtZW50c1xyXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG9wdGlvbnMuaW5pdGlhbExlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgIHg6IG9wdGlvbnMueCAtIGkgKiBNYXRoLmNvcyhvcHRpb25zLmluaXRpYWxBbmdsZSkgKiAyMCxcclxuICAgICAgICAgIHk6IG9wdGlvbnMueSAtIGkgKiBNYXRoLnNpbihvcHRpb25zLmluaXRpYWxBbmdsZSkgKiAyMCxcclxuICAgICAgICAgIHJhZGl1czogMTIgIC8vIFNsaWdodGx5IGxhcmdlciBib2R5IHNlZ21lbnRzXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyBJbml0aWFsaXplIGhpc3Rvcnkgd2l0aCBoZWFkIHBvc2l0aW9uXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2goeyB4OiBvcHRpb25zLngsIHk6IG9wdGlvbnMueSB9KVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgXHJcbiAgICB1cGRhdGUoY2FudmFzV2lkdGg6IG51bWJlciwgY2FudmFzSGVpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgLy8gVXBkYXRlIHZlbG9jaXR5IGJhc2VkIG9uIGN1cnJlbnQgYW5nbGVcclxuICAgICAgdGhpcy52ZWxvY2l0eSA9IHtcclxuICAgICAgICB4OiBNYXRoLmNvcyh0aGlzLmFuZ2xlKSAqIHRoaXMuc3BlZWQsXHJcbiAgICAgICAgeTogTWF0aC5zaW4odGhpcy5hbmdsZSkgKiB0aGlzLnNwZWVkLFxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIE1vdmUgaGVhZFxyXG4gICAgICBjb25zdCBoZWFkID0gdGhpcy5zZWdtZW50c1swXTtcclxuICAgICAgY29uc3QgbmV3WCA9IGhlYWQueCArIHRoaXMudmVsb2NpdHkueDtcclxuICAgICAgY29uc3QgbmV3WSA9IGhlYWQueSArIHRoaXMudmVsb2NpdHkueTtcclxuICBcclxuICAgICAgLy8gSGFuZGxlIHdyYXBwaW5nIGFyb3VuZCBlZGdlc1xyXG4gICAgICBsZXQgd3JhcHBlZFggPSBuZXdYO1xyXG4gICAgICBsZXQgd3JhcHBlZFkgPSBuZXdZO1xyXG4gIFxyXG4gICAgICBpZiAod3JhcHBlZFggPCAwKSB3cmFwcGVkWCA9IGNhbnZhc1dpZHRoO1xyXG4gICAgICBpZiAod3JhcHBlZFggPiBjYW52YXNXaWR0aCkgd3JhcHBlZFggPSAwO1xyXG4gICAgICBpZiAod3JhcHBlZFkgPCAwKSB3cmFwcGVkWSA9IGNhbnZhc0hlaWdodDtcclxuICAgICAgaWYgKHdyYXBwZWRZID4gY2FudmFzSGVpZ2h0KSB3cmFwcGVkWSA9IDA7XHJcbiAgXHJcbiAgICAgIC8vIFVwZGF0ZSBoZWFkIHBvc2l0aW9uXHJcbiAgICAgIGhlYWQueCA9IHdyYXBwZWRYO1xyXG4gICAgICBoZWFkLnkgPSB3cmFwcGVkWTtcclxuICBcclxuICAgICAgLy8gQWRkIG5ldyBwb3NpdGlvbiB0byBoaXN0b3J5XHJcbiAgICAgIHRoaXMuaGlzdG9yeS51bnNoaWZ0KHsgeDogd3JhcHBlZFgsIHk6IHdyYXBwZWRZIH0pO1xyXG4gICAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLmhpc3Rvcnkuc2xpY2UoMCwgMTAwMCk7IC8vIEtlZXAgbGFzdCAxMDAwIHBvc2l0aW9uc1xyXG4gIFxyXG4gICAgICAvLyBVcGRhdGUgYm9keSBzZWdtZW50c1xyXG4gICAgICBjb25zdCBzcGFjaW5nID0gMjA7IC8vIERpc3RhbmNlIGJldHdlZW4gc2VnbWVudHNcclxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHRoaXMuc2VnbWVudHNbaV07XHJcbiAgICAgICAgY29uc3QgaGlzdG9yeUluZGV4ID0gaSAqIDU7IC8vIFVzZSBoaXN0b3J5IHRvIGNyZWF0ZSBzbW9vdGggZm9sbG93aW5nXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRoaXMuaGlzdG9yeVtoaXN0b3J5SW5kZXhdKSB7XHJcbiAgICAgICAgICBzZWdtZW50LnggPSB0aGlzLmhpc3RvcnlbaGlzdG9yeUluZGV4XS54O1xyXG4gICAgICAgICAgc2VnbWVudC55ID0gdGhpcy5oaXN0b3J5W2hpc3RvcnlJbmRleF0ueTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBcclxuICAgIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgY3R4LnNhdmUoKVxyXG4gICAgICBcclxuICAgICAgLy8gQXBwbHkgdmlzdWFsIGVmZmVjdHMgYmFzZWQgb24gcG93ZXItdXBzXHJcbiAgICAgIGlmICh0aGlzLmlzSW52dWxuZXJhYmxlKSB7XHJcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJyNmMGYnXHJcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAyMFxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAodGhpcy5pc0dob3N0KSB7XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLy8gRHJhdyBib2R5IHNlZ21lbnRzXHJcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnNlZ21lbnRzLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICBjb25zdCBzZWdtZW50ID0gdGhpcy5zZWdtZW50c1tpXVxyXG4gIFxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgIGN0eC5hcmMoc2VnbWVudC54LCBzZWdtZW50LnksIHNlZ21lbnQucmFkaXVzLCAwLCBNYXRoLlBJICogMilcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvclxyXG4gICAgICAgIGN0eC5maWxsKClcclxuICBcclxuICAgICAgICAvLyBBZGQgZ2xvdyBlZmZlY3RcclxuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLmNvbG9yXHJcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxMFxyXG4gICAgICAgIGN0eC5maWxsKClcclxuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDBcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyBEcmF3IGhlYWRcclxuICAgICAgY29uc3QgaGVhZCA9IHRoaXMuc2VnbWVudHNbMF1cclxuICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgIGN0eC5hcmMoaGVhZC54LCBoZWFkLnksIGhlYWQucmFkaXVzLCAwLCBNYXRoLlBJICogMilcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuaGVhZENvbG9yXHJcbiAgICAgIGN0eC5maWxsKClcclxuICBcclxuICAgICAgLy8gQWRkIGdsb3cgZWZmZWN0IHRvIGhlYWRcclxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5oZWFkQ29sb3JcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxNVxyXG4gICAgICBjdHguZmlsbCgpXHJcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gMFxyXG4gIFxyXG4gICAgICAvLyBEcmF3IGV5ZXNcclxuICAgICAgY29uc3QgZXllT2Zmc2V0ID0gM1xyXG4gICAgICBjb25zdCBleWVSYWRpdXMgPSAyXHJcbiAgXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBleWUgcG9zaXRpb25zIGJhc2VkIG9uIGFuZ2xlXHJcbiAgICAgIGNvbnN0IGxlZnRFeWVYID0gaGVhZC54ICsgTWF0aC5jb3ModGhpcy5hbmdsZSAtIDAuMykgKiBleWVPZmZzZXRcclxuICAgICAgY29uc3QgbGVmdEV5ZVkgPSBoZWFkLnkgKyBNYXRoLnNpbih0aGlzLmFuZ2xlIC0gMC4zKSAqIGV5ZU9mZnNldFxyXG4gICAgICBjb25zdCByaWdodEV5ZVggPSBoZWFkLnggKyBNYXRoLmNvcyh0aGlzLmFuZ2xlICsgMC4zKSAqIGV5ZU9mZnNldFxyXG4gICAgICBjb25zdCByaWdodEV5ZVkgPSBoZWFkLnkgKyBNYXRoLnNpbih0aGlzLmFuZ2xlICsgMC4zKSAqIGV5ZU9mZnNldFxyXG4gIFxyXG4gICAgICAvLyBEcmF3IGxlZnQgZXllXHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICBjdHguYXJjKGxlZnRFeWVYLCBsZWZ0RXllWSwgZXllUmFkaXVzLCAwLCBNYXRoLlBJICogMilcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZlwiXHJcbiAgICAgIGN0eC5maWxsKClcclxuICBcclxuICAgICAgLy8gRHJhdyByaWdodCBleWVcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgIGN0eC5hcmMocmlnaHRFeWVYLCByaWdodEV5ZVksIGV5ZVJhZGl1cywgMCwgTWF0aC5QSSAqIDIpXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmZcIlxyXG4gICAgICBjdHguZmlsbCgpXHJcbiAgXHJcbiAgICAgIGN0eC5yZXN0b3JlKClcclxuICAgIH1cclxuICBcclxuICAgIHR1cm5MZWZ0KCkge1xyXG4gICAgICB0aGlzLmFuZ2xlIC09IHRoaXMudHVybmluZ1NwZWVkO1xyXG4gICAgICBjb25zb2xlLmxvZygnVHVybmluZyBsZWZ0LCBuZXcgYW5nbGU6JywgdGhpcy5hbmdsZSk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICB0dXJuUmlnaHQoKSB7XHJcbiAgICAgIHRoaXMuYW5nbGUgKz0gdGhpcy50dXJuaW5nU3BlZWQ7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdUdXJuaW5nIHJpZ2h0LCBuZXcgYW5nbGU6JywgdGhpcy5hbmdsZSk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBib29zdCgpIHtcclxuICAgICAgdGhpcy5zcGVlZCA9IHRoaXMuYmFzZVNwZWVkICogMjtcclxuICAgIH1cclxuICBcclxuICAgIG5vcm1hbFNwZWVkKCkge1xyXG4gICAgICB0aGlzLnNwZWVkID0gdGhpcy5iYXNlU3BlZWQ7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBncm93KGFtb3VudDogbnVtYmVyKSB7XHJcbiAgICAgIC8vIEluY3JlYXNlIHRhcmdldCBsZW5ndGhcclxuICAgICAgdGhpcy50YXJnZXRMZW5ndGggKz0gYW1vdW50XHJcbiAgXHJcbiAgICAgIC8vIEFkZCBzZWdtZW50cyBpZiBuZWVkZWRcclxuICAgICAgd2hpbGUgKHRoaXMuc2VnbWVudHMubGVuZ3RoIDwgdGhpcy50YXJnZXRMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSB0aGlzLnNlZ21lbnRzLmxlbmd0aCAtIDFcclxuICAgICAgICBjb25zdCBoaXN0b3J5SW5kZXggPSBNYXRoLm1pbihsYXN0SW5kZXggKiA1LCB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMSlcclxuICBcclxuICAgICAgICAvLyBHZXQgcG9zaXRpb24gZnJvbSBoaXN0b3J5XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmhpc3RvcnlbaGlzdG9yeUluZGV4XVxyXG4gIFxyXG4gICAgICAgIC8vIEFkZCBuZXcgc2VnbWVudFxyXG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICB4OiBwb3NpdGlvbi54LFxyXG4gICAgICAgICAgeTogcG9zaXRpb24ueSxcclxuICAgICAgICAgIHJhZGl1czogOCAtIE1hdGgubWluKDMsIHRoaXMuc2VnbWVudHMubGVuZ3RoICogMC4xKSwgLy8gR3JhZHVhbGx5IGRlY3JlYXNlIHNpemVcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgXHJcbiAgICBnZXRIZWFkKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zZWdtZW50c1swXVxyXG4gICAgfVxyXG4gIFxyXG4gICAgY2hlY2tTZWxmQ29sbGlzaW9uKCkge1xyXG4gICAgICBjb25zdCBoZWFkID0gdGhpcy5nZXRIZWFkKClcclxuICBcclxuICAgICAgLy8gU2tpcCB0aGUgZmlyc3QgZmV3IHNlZ21lbnRzIHRvIHByZXZlbnQgZmFsc2UgY29sbGlzaW9uc1xyXG4gICAgICBmb3IgKGxldCBpID0gMTA7IGkgPCB0aGlzLnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHRoaXMuc2VnbWVudHNbaV1cclxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguaHlwb3QoaGVhZC54IC0gc2VnbWVudC54LCBoZWFkLnkgLSBzZWdtZW50LnkpXHJcbiAgXHJcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgaGVhZC5yYWRpdXMgKyBzZWdtZW50LnJhZGl1cyAqIDAuNSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgXHJcbiAgICBjaGVja0NvbGxpc2lvbldpdGhQb2ludChwb2ludDogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgcmFkaXVzOiBudW1iZXIgfSkge1xyXG4gICAgICAvLyBTa2lwIHRoZSBoZWFkXHJcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5zZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSB0aGlzLnNlZ21lbnRzW2ldXHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmh5cG90KHBvaW50LnggLSBzZWdtZW50LngsIHBvaW50LnkgLSBzZWdtZW50LnkpXHJcbiAgXHJcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgcG9pbnQucmFkaXVzICsgc2VnbWVudC5yYWRpdXMgKiAwLjgpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIFxyXG4gICAgY29sbGVjdFBvd2VyVXAocG93ZXJVcDogUG93ZXJVcCkge1xyXG4gICAgICB0aGlzLmFjdGl2ZVBvd2VyVXBzLnNldChwb3dlclVwLnR5cGUsIERhdGUubm93KCkgKyBwb3dlclVwLmR1cmF0aW9uKVxyXG4gICAgICBwb3dlclVwLmFwcGx5RWZmZWN0KHRoaXMpXHJcbiAgICAgIEF1ZGlvU3lzdGVtLmdldEluc3RhbmNlKCkucGxheVNvdW5kKCdwb3dlcnVwJylcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgIl0sIm5hbWVzIjpbIkF1ZGlvU3lzdGVtIiwiU25ha2UiLCJ1cGRhdGUiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsInZlbG9jaXR5IiwieCIsIk1hdGgiLCJjb3MiLCJhbmdsZSIsInNwZWVkIiwieSIsInNpbiIsImhlYWQiLCJzZWdtZW50cyIsIm5ld1giLCJuZXdZIiwid3JhcHBlZFgiLCJ3cmFwcGVkWSIsImhpc3RvcnkiLCJ1bnNoaWZ0Iiwic2xpY2UiLCJzcGFjaW5nIiwiaSIsImxlbmd0aCIsInNlZ21lbnQiLCJoaXN0b3J5SW5kZXgiLCJkcmF3IiwiY3R4Iiwic2F2ZSIsImlzSW52dWxuZXJhYmxlIiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwiaXNHaG9zdCIsImdsb2JhbEFscGhhIiwiYmVnaW5QYXRoIiwiYXJjIiwicmFkaXVzIiwiUEkiLCJmaWxsU3R5bGUiLCJjb2xvciIsImZpbGwiLCJoZWFkQ29sb3IiLCJleWVPZmZzZXQiLCJleWVSYWRpdXMiLCJsZWZ0RXllWCIsImxlZnRFeWVZIiwicmlnaHRFeWVYIiwicmlnaHRFeWVZIiwicmVzdG9yZSIsInR1cm5MZWZ0IiwidHVybmluZ1NwZWVkIiwiY29uc29sZSIsImxvZyIsInR1cm5SaWdodCIsImJvb3N0IiwiYmFzZVNwZWVkIiwibm9ybWFsU3BlZWQiLCJncm93IiwiYW1vdW50IiwidGFyZ2V0TGVuZ3RoIiwibGFzdEluZGV4IiwibWluIiwicG9zaXRpb24iLCJwdXNoIiwiZ2V0SGVhZCIsImNoZWNrU2VsZkNvbGxpc2lvbiIsImRpc3RhbmNlIiwiaHlwb3QiLCJjaGVja0NvbGxpc2lvbldpdGhQb2ludCIsInBvaW50IiwiY29sbGVjdFBvd2VyVXAiLCJwb3dlclVwIiwiYWN0aXZlUG93ZXJVcHMiLCJzZXQiLCJ0eXBlIiwiRGF0ZSIsIm5vdyIsImR1cmF0aW9uIiwiYXBwbHlFZmZlY3QiLCJnZXRJbnN0YW5jZSIsInBsYXlTb3VuZCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIk1hcCIsImluaXRpYWxBbmdsZSIsImluaXRpYWxMZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/snake.tsx\n"));

/***/ })

});