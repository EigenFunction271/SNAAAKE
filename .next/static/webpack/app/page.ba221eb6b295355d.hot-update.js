"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/snake.tsx":
/*!*************************!*\
  !*** ./utils/snake.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Snake: function() { return /* binding */ Snake; }\n/* harmony export */ });\n/* harmony import */ var _audio_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audio-system */ \"(app-pages-browser)/./utils/audio-system.tsx\");\n\nclass Snake {\n    update(canvasWidth, canvasHeight) {\n        // Update velocity based on current angle\n        this.velocity = {\n            x: Math.cos(this.angle) * this.speed,\n            y: Math.sin(this.angle) * this.speed\n        };\n        // Move head\n        const head = this.segments[0];\n        const newX = head.x + this.velocity.x;\n        const newY = head.y + this.velocity.y;\n        // Handle wrapping around edges (periodic boundary conditions)\n        let wrappedX = newX;\n        let wrappedY = newY;\n        if (newX < 0) wrappedX = canvasWidth;\n        if (newX > canvasWidth) wrappedX = 0;\n        if (newY < 0) wrappedY = canvasHeight;\n        if (newY > canvasHeight) wrappedY = 0;\n        // Add new position to history\n        this.history.unshift({\n            x: wrappedX,\n            y: wrappedY\n        });\n        this.history = this.history.slice(0, 1000) // Limit history length\n        ;\n        // Update head position\n        head.x = wrappedX;\n        head.y = wrappedY;\n        // Grow snake if needed\n        this.grow(0) // This will handle segment positioning\n        ;\n    }\n    draw(ctx) {\n        ctx.save();\n        // Apply visual effects based on power-ups\n        if (this.isInvulnerable) {\n            ctx.shadowColor = \"#f0f\";\n            ctx.shadowBlur = 20;\n        }\n        if (this.isGhost) {\n            ctx.globalAlpha = 0.6;\n        }\n        // Draw body segments\n        for(let i = this.segments.length - 1; i > 0; i--){\n            const segment = this.segments[i];\n            ctx.beginPath();\n            ctx.arc(segment.x, segment.y, segment.radius, 0, Math.PI * 2);\n            ctx.fillStyle = this.color;\n            ctx.fill();\n            // Add glow effect\n            ctx.shadowColor = this.color;\n            ctx.shadowBlur = 10;\n            ctx.fill();\n            ctx.shadowBlur = 0;\n        }\n        // Draw head\n        const head = this.segments[0];\n        ctx.beginPath();\n        ctx.arc(head.x, head.y, head.radius, 0, Math.PI * 2);\n        ctx.fillStyle = this.headColor;\n        ctx.fill();\n        // Add glow effect to head\n        ctx.shadowColor = this.headColor;\n        ctx.shadowBlur = 15;\n        ctx.fill();\n        ctx.shadowBlur = 0;\n        // Draw eyes\n        const eyeOffset = 3;\n        const eyeRadius = 2;\n        // Calculate eye positions based on angle\n        const leftEyeX = head.x + Math.cos(this.angle - 0.3) * eyeOffset;\n        const leftEyeY = head.y + Math.sin(this.angle - 0.3) * eyeOffset;\n        const rightEyeX = head.x + Math.cos(this.angle + 0.3) * eyeOffset;\n        const rightEyeY = head.y + Math.sin(this.angle + 0.3) * eyeOffset;\n        // Draw left eye\n        ctx.beginPath();\n        ctx.arc(leftEyeX, leftEyeY, eyeRadius, 0, Math.PI * 2);\n        ctx.fillStyle = \"#fff\";\n        ctx.fill();\n        // Draw right eye\n        ctx.beginPath();\n        ctx.arc(rightEyeX, rightEyeY, eyeRadius, 0, Math.PI * 2);\n        ctx.fillStyle = \"#fff\";\n        ctx.fill();\n        ctx.restore();\n    }\n    turnLeft() {\n        this.angle -= this.turningSpeed;\n    }\n    turnRight() {\n        this.angle += this.turningSpeed;\n    }\n    boost() {\n        this.speed = this.baseSpeed * 1.5;\n    }\n    normalSpeed() {\n        this.speed = this.baseSpeed;\n    }\n    grow(amount) {\n        // Increase target length\n        this.targetLength += amount;\n        // Add segments if needed\n        while(this.segments.length < this.targetLength){\n            const lastIndex = this.segments.length - 1;\n            const historyIndex = Math.min(lastIndex * 5, this.history.length - 1);\n            // Get position from history\n            const position = this.history[historyIndex];\n            // Add new segment\n            this.segments.push({\n                x: position.x,\n                y: position.y,\n                radius: 8 - Math.min(3, this.segments.length * 0.1)\n            });\n        }\n    }\n    getHead() {\n        return this.segments[0];\n    }\n    checkSelfCollision() {\n        const head = this.getHead();\n        // Skip the first few segments to prevent false collisions\n        for(let i = 10; i < this.segments.length; i++){\n            const segment = this.segments[i];\n            const distance = Math.hypot(head.x - segment.x, head.y - segment.y);\n            if (distance < head.radius + segment.radius * 0.5) {\n                return true;\n            }\n        }\n        return false;\n    }\n    checkCollisionWithPoint(point) {\n        // Skip the head\n        for(let i = 1; i < this.segments.length; i++){\n            const segment = this.segments[i];\n            const distance = Math.hypot(point.x - segment.x, point.y - segment.y);\n            if (distance < point.radius + segment.radius * 0.8) {\n                return true;\n            }\n        }\n        return false;\n    }\n    collectPowerUp(powerUp) {\n        this.activePowerUps.set(powerUp.type, Date.now() + powerUp.duration);\n        powerUp.applyEffect(this);\n        _audio_system__WEBPACK_IMPORTED_MODULE_0__.AudioSystem.getInstance().playSound(\"powerup\");\n    }\n    constructor(options){\n        this.segments = [];\n        this.velocity = {\n            x: 0,\n            y: 0\n        };\n        this.turningSpeed = 0.05;\n        this.history = [];\n        this.isInvulnerable = false;\n        this.isGhost = false;\n        this.activePowerUps = new Map();\n        this.angle = options.initialAngle;\n        this.speed = options.speed;\n        this.baseSpeed = options.speed;\n        this.color = options.color;\n        this.headColor = options.headColor;\n        this.targetLength = options.initialLength;\n        // Initialize first segment (head)\n        this.segments.push({\n            x: options.x,\n            y: options.y,\n            radius: 15 // Increased head radius for better collision detection\n        });\n        // Add initial body segments\n        for(let i = 1; i < options.initialLength; i++){\n            this.segments.push({\n                x: options.x - i * Math.cos(options.initialAngle) * 20,\n                y: options.y - i * Math.sin(options.initialAngle) * 20,\n                radius: 12 // Slightly larger body segments\n            });\n        }\n        // Initialize history with head position\n        for(let i = 0; i < 1000; i++){\n            this.history.push({\n                x: options.x,\n                y: options.y\n            });\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dHN4PzY1MGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG93ZXJVcFR5cGUgfSBmcm9tICcuL3Bvd2VyLXVwJztcclxuaW1wb3J0IHsgQXVkaW9TeXN0ZW0gfSBmcm9tICcuL2F1ZGlvLXN5c3RlbSc7XHJcblxyXG5pbnRlcmZhY2UgUG93ZXJVcCB7XHJcbiAgdHlwZTogUG93ZXJVcFR5cGU7XHJcbiAgZHVyYXRpb246IG51bWJlcjtcclxuICBhcHBseUVmZmVjdDogKHNuYWtlOiBTbmFrZSkgPT4gdm9pZDtcclxufVxyXG5cclxuLy8gU25ha2Ugc2VnbWVudCBpbnRlcmZhY2VcclxuaW50ZXJmYWNlIFNuYWtlU2VnbWVudCB7XHJcbiAgICB4OiBudW1iZXJcclxuICAgIHk6IG51bWJlclxyXG4gICAgcmFkaXVzOiBudW1iZXJcclxuICB9XHJcbiAgXHJcbiAgLy8gU25ha2Ugb3B0aW9ucyBpbnRlcmZhY2VcclxuICBpbnRlcmZhY2UgU25ha2VPcHRpb25zIHtcclxuICAgIHg6IG51bWJlclxyXG4gICAgeTogbnVtYmVyXHJcbiAgICBjb2xvcjogc3RyaW5nXHJcbiAgICBoZWFkQ29sb3I6IHN0cmluZ1xyXG4gICAgaW5pdGlhbExlbmd0aDogbnVtYmVyXHJcbiAgICBpbml0aWFsQW5nbGU6IG51bWJlclxyXG4gICAgc3BlZWQ6IG51bWJlclxyXG4gIH1cclxuICBcclxuICBleHBvcnQgY2xhc3MgU25ha2Uge1xyXG4gICAgc2VnbWVudHM6IFNuYWtlU2VnbWVudFtdID0gW11cclxuICAgIHZlbG9jaXR5ID0geyB4OiAwLCB5OiAwIH1cclxuICAgIGFuZ2xlOiBudW1iZXJcclxuICAgIHNwZWVkOiBudW1iZXJcclxuICAgIGJhc2VTcGVlZDogbnVtYmVyXHJcbiAgICB0dXJuaW5nU3BlZWQgPSAwLjA1XHJcbiAgICBjb2xvcjogc3RyaW5nXHJcbiAgICBoZWFkQ29sb3I6IHN0cmluZ1xyXG4gICAgdGFyZ2V0TGVuZ3RoOiBudW1iZXJcclxuICAgIGhpc3Rvcnk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfVtdID0gW11cclxuICAgIGlzSW52dWxuZXJhYmxlOiBib29sZWFuID0gZmFsc2VcclxuICAgIGlzR2hvc3Q6IGJvb2xlYW4gPSBmYWxzZVxyXG4gICAgYWN0aXZlUG93ZXJVcHM6IE1hcDxQb3dlclVwVHlwZSwgbnVtYmVyPiA9IG5ldyBNYXAoKVxyXG4gIFxyXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogU25ha2VPcHRpb25zKSB7XHJcbiAgICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmluaXRpYWxBbmdsZVxyXG4gICAgICB0aGlzLnNwZWVkID0gb3B0aW9ucy5zcGVlZFxyXG4gICAgICB0aGlzLmJhc2VTcGVlZCA9IG9wdGlvbnMuc3BlZWRcclxuICAgICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3JcclxuICAgICAgdGhpcy5oZWFkQ29sb3IgPSBvcHRpb25zLmhlYWRDb2xvclxyXG4gICAgICB0aGlzLnRhcmdldExlbmd0aCA9IG9wdGlvbnMuaW5pdGlhbExlbmd0aFxyXG4gIFxyXG4gICAgICAvLyBJbml0aWFsaXplIGZpcnN0IHNlZ21lbnQgKGhlYWQpXHJcbiAgICAgIHRoaXMuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgeDogb3B0aW9ucy54LFxyXG4gICAgICAgIHk6IG9wdGlvbnMueSxcclxuICAgICAgICByYWRpdXM6IDE1ICAvLyBJbmNyZWFzZWQgaGVhZCByYWRpdXMgZm9yIGJldHRlciBjb2xsaXNpb24gZGV0ZWN0aW9uXHJcbiAgICAgIH0pXHJcbiAgXHJcbiAgICAgIC8vIEFkZCBpbml0aWFsIGJvZHkgc2VnbWVudHNcclxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBvcHRpb25zLmluaXRpYWxMZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICB4OiBvcHRpb25zLnggLSBpICogTWF0aC5jb3Mob3B0aW9ucy5pbml0aWFsQW5nbGUpICogMjAsXHJcbiAgICAgICAgICB5OiBvcHRpb25zLnkgLSBpICogTWF0aC5zaW4ob3B0aW9ucy5pbml0aWFsQW5nbGUpICogMjAsXHJcbiAgICAgICAgICByYWRpdXM6IDEyICAvLyBTbGlnaHRseSBsYXJnZXIgYm9keSBzZWdtZW50c1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLy8gSW5pdGlhbGl6ZSBoaXN0b3J5IHdpdGggaGVhZCBwb3NpdGlvblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDA7IGkrKykge1xyXG4gICAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKHsgeDogb3B0aW9ucy54LCB5OiBvcHRpb25zLnkgfSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgdXBkYXRlKGNhbnZhc1dpZHRoOiBudW1iZXIsIGNhbnZhc0hlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgIC8vIFVwZGF0ZSB2ZWxvY2l0eSBiYXNlZCBvbiBjdXJyZW50IGFuZ2xlXHJcbiAgICAgIHRoaXMudmVsb2NpdHkgPSB7XHJcbiAgICAgICAgeDogTWF0aC5jb3ModGhpcy5hbmdsZSkgKiB0aGlzLnNwZWVkLFxyXG4gICAgICAgIHk6IE1hdGguc2luKHRoaXMuYW5nbGUpICogdGhpcy5zcGVlZCxcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyBNb3ZlIGhlYWRcclxuICAgICAgY29uc3QgaGVhZCA9IHRoaXMuc2VnbWVudHNbMF1cclxuICAgICAgY29uc3QgbmV3WCA9IGhlYWQueCArIHRoaXMudmVsb2NpdHkueFxyXG4gICAgICBjb25zdCBuZXdZID0gaGVhZC55ICsgdGhpcy52ZWxvY2l0eS55XHJcbiAgXHJcbiAgICAgIC8vIEhhbmRsZSB3cmFwcGluZyBhcm91bmQgZWRnZXMgKHBlcmlvZGljIGJvdW5kYXJ5IGNvbmRpdGlvbnMpXHJcbiAgICAgIGxldCB3cmFwcGVkWCA9IG5ld1hcclxuICAgICAgbGV0IHdyYXBwZWRZID0gbmV3WVxyXG4gIFxyXG4gICAgICBpZiAobmV3WCA8IDApIHdyYXBwZWRYID0gY2FudmFzV2lkdGhcclxuICAgICAgaWYgKG5ld1ggPiBjYW52YXNXaWR0aCkgd3JhcHBlZFggPSAwXHJcbiAgICAgIGlmIChuZXdZIDwgMCkgd3JhcHBlZFkgPSBjYW52YXNIZWlnaHRcclxuICAgICAgaWYgKG5ld1kgPiBjYW52YXNIZWlnaHQpIHdyYXBwZWRZID0gMFxyXG4gIFxyXG4gICAgICAvLyBBZGQgbmV3IHBvc2l0aW9uIHRvIGhpc3RvcnlcclxuICAgICAgdGhpcy5oaXN0b3J5LnVuc2hpZnQoeyB4OiB3cmFwcGVkWCwgeTogd3JhcHBlZFkgfSlcclxuICAgICAgdGhpcy5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5LnNsaWNlKDAsIDEwMDApIC8vIExpbWl0IGhpc3RvcnkgbGVuZ3RoXHJcbiAgXHJcbiAgICAgIC8vIFVwZGF0ZSBoZWFkIHBvc2l0aW9uXHJcbiAgICAgIGhlYWQueCA9IHdyYXBwZWRYXHJcbiAgICAgIGhlYWQueSA9IHdyYXBwZWRZXHJcbiAgXHJcbiAgICAgIC8vIEdyb3cgc25ha2UgaWYgbmVlZGVkXHJcbiAgICAgIHRoaXMuZ3JvdygwKSAvLyBUaGlzIHdpbGwgaGFuZGxlIHNlZ21lbnQgcG9zaXRpb25pbmdcclxuICAgIH1cclxuICBcclxuICAgIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgY3R4LnNhdmUoKVxyXG4gICAgICBcclxuICAgICAgLy8gQXBwbHkgdmlzdWFsIGVmZmVjdHMgYmFzZWQgb24gcG93ZXItdXBzXHJcbiAgICAgIGlmICh0aGlzLmlzSW52dWxuZXJhYmxlKSB7XHJcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJyNmMGYnXHJcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAyMFxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAodGhpcy5pc0dob3N0KSB7XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLy8gRHJhdyBib2R5IHNlZ21lbnRzXHJcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnNlZ21lbnRzLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICBjb25zdCBzZWdtZW50ID0gdGhpcy5zZWdtZW50c1tpXVxyXG4gIFxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgIGN0eC5hcmMoc2VnbWVudC54LCBzZWdtZW50LnksIHNlZ21lbnQucmFkaXVzLCAwLCBNYXRoLlBJICogMilcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvclxyXG4gICAgICAgIGN0eC5maWxsKClcclxuICBcclxuICAgICAgICAvLyBBZGQgZ2xvdyBlZmZlY3RcclxuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLmNvbG9yXHJcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxMFxyXG4gICAgICAgIGN0eC5maWxsKClcclxuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDBcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyBEcmF3IGhlYWRcclxuICAgICAgY29uc3QgaGVhZCA9IHRoaXMuc2VnbWVudHNbMF1cclxuICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgIGN0eC5hcmMoaGVhZC54LCBoZWFkLnksIGhlYWQucmFkaXVzLCAwLCBNYXRoLlBJICogMilcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuaGVhZENvbG9yXHJcbiAgICAgIGN0eC5maWxsKClcclxuICBcclxuICAgICAgLy8gQWRkIGdsb3cgZWZmZWN0IHRvIGhlYWRcclxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5oZWFkQ29sb3JcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxNVxyXG4gICAgICBjdHguZmlsbCgpXHJcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gMFxyXG4gIFxyXG4gICAgICAvLyBEcmF3IGV5ZXNcclxuICAgICAgY29uc3QgZXllT2Zmc2V0ID0gM1xyXG4gICAgICBjb25zdCBleWVSYWRpdXMgPSAyXHJcbiAgXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBleWUgcG9zaXRpb25zIGJhc2VkIG9uIGFuZ2xlXHJcbiAgICAgIGNvbnN0IGxlZnRFeWVYID0gaGVhZC54ICsgTWF0aC5jb3ModGhpcy5hbmdsZSAtIDAuMykgKiBleWVPZmZzZXRcclxuICAgICAgY29uc3QgbGVmdEV5ZVkgPSBoZWFkLnkgKyBNYXRoLnNpbih0aGlzLmFuZ2xlIC0gMC4zKSAqIGV5ZU9mZnNldFxyXG4gICAgICBjb25zdCByaWdodEV5ZVggPSBoZWFkLnggKyBNYXRoLmNvcyh0aGlzLmFuZ2xlICsgMC4zKSAqIGV5ZU9mZnNldFxyXG4gICAgICBjb25zdCByaWdodEV5ZVkgPSBoZWFkLnkgKyBNYXRoLnNpbih0aGlzLmFuZ2xlICsgMC4zKSAqIGV5ZU9mZnNldFxyXG4gIFxyXG4gICAgICAvLyBEcmF3IGxlZnQgZXllXHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICBjdHguYXJjKGxlZnRFeWVYLCBsZWZ0RXllWSwgZXllUmFkaXVzLCAwLCBNYXRoLlBJICogMilcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZlwiXHJcbiAgICAgIGN0eC5maWxsKClcclxuICBcclxuICAgICAgLy8gRHJhdyByaWdodCBleWVcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgIGN0eC5hcmMocmlnaHRFeWVYLCByaWdodEV5ZVksIGV5ZVJhZGl1cywgMCwgTWF0aC5QSSAqIDIpXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmZcIlxyXG4gICAgICBjdHguZmlsbCgpXHJcbiAgXHJcbiAgICAgIGN0eC5yZXN0b3JlKClcclxuICAgIH1cclxuICBcclxuICAgIHR1cm5MZWZ0KCkge1xyXG4gICAgICB0aGlzLmFuZ2xlIC09IHRoaXMudHVybmluZ1NwZWVkXHJcbiAgICB9XHJcbiAgXHJcbiAgICB0dXJuUmlnaHQoKSB7XHJcbiAgICAgIHRoaXMuYW5nbGUgKz0gdGhpcy50dXJuaW5nU3BlZWRcclxuICAgIH1cclxuICBcclxuICAgIGJvb3N0KCkge1xyXG4gICAgICB0aGlzLnNwZWVkID0gdGhpcy5iYXNlU3BlZWQgKiAxLjVcclxuICAgIH1cclxuICBcclxuICAgIG5vcm1hbFNwZWVkKCkge1xyXG4gICAgICB0aGlzLnNwZWVkID0gdGhpcy5iYXNlU3BlZWRcclxuICAgIH1cclxuICBcclxuICAgIGdyb3coYW1vdW50OiBudW1iZXIpIHtcclxuICAgICAgLy8gSW5jcmVhc2UgdGFyZ2V0IGxlbmd0aFxyXG4gICAgICB0aGlzLnRhcmdldExlbmd0aCArPSBhbW91bnRcclxuICBcclxuICAgICAgLy8gQWRkIHNlZ21lbnRzIGlmIG5lZWRlZFxyXG4gICAgICB3aGlsZSAodGhpcy5zZWdtZW50cy5sZW5ndGggPCB0aGlzLnRhcmdldExlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHRoaXMuc2VnbWVudHMubGVuZ3RoIC0gMVxyXG4gICAgICAgIGNvbnN0IGhpc3RvcnlJbmRleCA9IE1hdGgubWluKGxhc3RJbmRleCAqIDUsIHRoaXMuaGlzdG9yeS5sZW5ndGggLSAxKVxyXG4gIFxyXG4gICAgICAgIC8vIEdldCBwb3NpdGlvbiBmcm9tIGhpc3RvcnlcclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuaGlzdG9yeVtoaXN0b3J5SW5kZXhdXHJcbiAgXHJcbiAgICAgICAgLy8gQWRkIG5ldyBzZWdtZW50XHJcbiAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgIHg6IHBvc2l0aW9uLngsXHJcbiAgICAgICAgICB5OiBwb3NpdGlvbi55LFxyXG4gICAgICAgICAgcmFkaXVzOiA4IC0gTWF0aC5taW4oMywgdGhpcy5zZWdtZW50cy5sZW5ndGggKiAwLjEpLCAvLyBHcmFkdWFsbHkgZGVjcmVhc2Ugc2l6ZVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgIH1cclxuICBcclxuICAgIGdldEhlYWQoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRzWzBdXHJcbiAgICB9XHJcbiAgXHJcbiAgICBjaGVja1NlbGZDb2xsaXNpb24oKSB7XHJcbiAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLmdldEhlYWQoKVxyXG4gIFxyXG4gICAgICAvLyBTa2lwIHRoZSBmaXJzdCBmZXcgc2VnbWVudHMgdG8gcHJldmVudCBmYWxzZSBjb2xsaXNpb25zXHJcbiAgICAgIGZvciAobGV0IGkgPSAxMDsgaSA8IHRoaXMuc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBzZWdtZW50ID0gdGhpcy5zZWdtZW50c1tpXVxyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5oeXBvdChoZWFkLnggLSBzZWdtZW50LngsIGhlYWQueSAtIHNlZ21lbnQueSlcclxuICBcclxuICAgICAgICBpZiAoZGlzdGFuY2UgPCBoZWFkLnJhZGl1cyArIHNlZ21lbnQucmFkaXVzICogMC41KSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gIFxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICBcclxuICAgIGNoZWNrQ29sbGlzaW9uV2l0aFBvaW50KHBvaW50OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyByYWRpdXM6IG51bWJlciB9KSB7XHJcbiAgICAgIC8vIFNraXAgdGhlIGhlYWRcclxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHRoaXMuc2VnbWVudHNbaV1cclxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguaHlwb3QocG9pbnQueCAtIHNlZ21lbnQueCwgcG9pbnQueSAtIHNlZ21lbnQueSlcclxuICBcclxuICAgICAgICBpZiAoZGlzdGFuY2UgPCBwb2ludC5yYWRpdXMgKyBzZWdtZW50LnJhZGl1cyAqIDAuOCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgXHJcbiAgICBjb2xsZWN0UG93ZXJVcChwb3dlclVwOiBQb3dlclVwKSB7XHJcbiAgICAgIHRoaXMuYWN0aXZlUG93ZXJVcHMuc2V0KHBvd2VyVXAudHlwZSwgRGF0ZS5ub3coKSArIHBvd2VyVXAuZHVyYXRpb24pXHJcbiAgICAgIHBvd2VyVXAuYXBwbHlFZmZlY3QodGhpcylcclxuICAgICAgQXVkaW9TeXN0ZW0uZ2V0SW5zdGFuY2UoKS5wbGF5U291bmQoJ3Bvd2VydXAnKVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAiXSwibmFtZXMiOlsiQXVkaW9TeXN0ZW0iLCJTbmFrZSIsInVwZGF0ZSIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwidmVsb2NpdHkiLCJ4IiwiTWF0aCIsImNvcyIsImFuZ2xlIiwic3BlZWQiLCJ5Iiwic2luIiwiaGVhZCIsInNlZ21lbnRzIiwibmV3WCIsIm5ld1kiLCJ3cmFwcGVkWCIsIndyYXBwZWRZIiwiaGlzdG9yeSIsInVuc2hpZnQiLCJzbGljZSIsImdyb3ciLCJkcmF3IiwiY3R4Iiwic2F2ZSIsImlzSW52dWxuZXJhYmxlIiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwiaXNHaG9zdCIsImdsb2JhbEFscGhhIiwiaSIsImxlbmd0aCIsInNlZ21lbnQiLCJiZWdpblBhdGgiLCJhcmMiLCJyYWRpdXMiLCJQSSIsImZpbGxTdHlsZSIsImNvbG9yIiwiZmlsbCIsImhlYWRDb2xvciIsImV5ZU9mZnNldCIsImV5ZVJhZGl1cyIsImxlZnRFeWVYIiwibGVmdEV5ZVkiLCJyaWdodEV5ZVgiLCJyaWdodEV5ZVkiLCJyZXN0b3JlIiwidHVybkxlZnQiLCJ0dXJuaW5nU3BlZWQiLCJ0dXJuUmlnaHQiLCJib29zdCIsImJhc2VTcGVlZCIsIm5vcm1hbFNwZWVkIiwiYW1vdW50IiwidGFyZ2V0TGVuZ3RoIiwibGFzdEluZGV4IiwiaGlzdG9yeUluZGV4IiwibWluIiwicG9zaXRpb24iLCJwdXNoIiwiZ2V0SGVhZCIsImNoZWNrU2VsZkNvbGxpc2lvbiIsImRpc3RhbmNlIiwiaHlwb3QiLCJjaGVja0NvbGxpc2lvbldpdGhQb2ludCIsInBvaW50IiwiY29sbGVjdFBvd2VyVXAiLCJwb3dlclVwIiwiYWN0aXZlUG93ZXJVcHMiLCJzZXQiLCJ0eXBlIiwiRGF0ZSIsIm5vdyIsImR1cmF0aW9uIiwiYXBwbHlFZmZlY3QiLCJnZXRJbnN0YW5jZSIsInBsYXlTb3VuZCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIk1hcCIsImluaXRpYWxBbmdsZSIsImluaXRpYWxMZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/snake.tsx\n"));

/***/ })

});