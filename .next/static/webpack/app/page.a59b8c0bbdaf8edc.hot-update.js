"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/snake.tsx":
/*!*************************!*\
  !*** ./utils/snake.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Snake: function() { return /* binding */ Snake; }\n/* harmony export */ });\n/* harmony import */ var _audio_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audio-system */ \"(app-pages-browser)/./utils/audio-system.tsx\");\n\nclass Snake {\n    update(canvasWidth, canvasHeight) {\n        // Update velocity based on current angle\n        this.velocity = {\n            x: Math.cos(this.angle) * this.speed,\n            y: Math.sin(this.angle) * this.speed\n        };\n        // Move head\n        const head = this.segments[0];\n        const newX = head.x + this.velocity.x;\n        const newY = head.y + this.velocity.y;\n        // Handle wrapping around edges (periodic boundary conditions)\n        let wrappedX = newX;\n        let wrappedY = newY;\n        if (newX < 0) wrappedX = canvasWidth;\n        if (newX > canvasWidth) wrappedX = 0;\n        if (newY < 0) wrappedY = canvasHeight;\n        if (newY > canvasHeight) wrappedY = 0;\n        // Add new position to history\n        this.history.unshift({\n            x: wrappedX,\n            y: wrappedY\n        });\n        this.history = this.history.slice(0, 1000) // Limit history length\n        ;\n        // Update head position\n        head.x = wrappedX;\n        head.y = wrappedY;\n        // Grow snake if needed\n        this.grow(0) // This will handle segment positioning\n        ;\n    }\n    draw(ctx) {\n        ctx.save();\n        // Apply visual effects based on power-ups\n        if (this.isInvulnerable) {\n            ctx.shadowColor = \"#f0f\";\n            ctx.shadowBlur = 20;\n        }\n        if (this.isGhost) {\n            ctx.globalAlpha = 0.6;\n        }\n        // Draw body segments\n        for(let i = this.segments.length - 1; i > 0; i--){\n            const segment = this.segments[i];\n            ctx.beginPath();\n            ctx.arc(segment.x, segment.y, segment.radius, 0, Math.PI * 2);\n            ctx.fillStyle = this.color;\n            ctx.fill();\n            // Add glow effect\n            ctx.shadowColor = this.color;\n            ctx.shadowBlur = 10;\n            ctx.fill();\n            ctx.shadowBlur = 0;\n        }\n        // Draw head\n        const head = this.segments[0];\n        ctx.beginPath();\n        ctx.arc(head.x, head.y, head.radius, 0, Math.PI * 2);\n        ctx.fillStyle = this.headColor;\n        ctx.fill();\n        // Add glow effect to head\n        ctx.shadowColor = this.headColor;\n        ctx.shadowBlur = 15;\n        ctx.fill();\n        ctx.shadowBlur = 0;\n        // Draw eyes\n        const eyeOffset = 3;\n        const eyeRadius = 2;\n        // Calculate eye positions based on angle\n        const leftEyeX = head.x + Math.cos(this.angle - 0.3) * eyeOffset;\n        const leftEyeY = head.y + Math.sin(this.angle - 0.3) * eyeOffset;\n        const rightEyeX = head.x + Math.cos(this.angle + 0.3) * eyeOffset;\n        const rightEyeY = head.y + Math.sin(this.angle + 0.3) * eyeOffset;\n        // Draw left eye\n        ctx.beginPath();\n        ctx.arc(leftEyeX, leftEyeY, eyeRadius, 0, Math.PI * 2);\n        ctx.fillStyle = \"#fff\";\n        ctx.fill();\n        // Draw right eye\n        ctx.beginPath();\n        ctx.arc(rightEyeX, rightEyeY, eyeRadius, 0, Math.PI * 2);\n        ctx.fillStyle = \"#fff\";\n        ctx.fill();\n        ctx.restore();\n    }\n    turnLeft() {\n        this.angle -= this.turningSpeed;\n    }\n    turnRight() {\n        this.angle += this.turningSpeed;\n    }\n    boost() {\n        this.speed = this.baseSpeed * 1.5;\n    }\n    normalSpeed() {\n        this.speed = this.baseSpeed;\n    }\n    grow(amount) {\n        // Increase target length\n        this.targetLength += amount;\n        // Add segments if needed\n        while(this.segments.length < this.targetLength){\n            const lastIndex = this.segments.length - 1;\n            const historyIndex = Math.min(lastIndex * 5, this.history.length - 1);\n            // Get position from history\n            const position = this.history[historyIndex];\n            // Add new segment\n            this.segments.push({\n                x: position.x,\n                y: position.y,\n                radius: 8 - Math.min(3, this.segments.length * 0.1)\n            });\n        }\n    }\n    getHead() {\n        return this.segments[0];\n    }\n    checkSelfCollision() {\n        const head = this.getHead();\n        // Skip the first few segments to prevent false collisions\n        for(let i = 10; i < this.segments.length; i++){\n            const segment = this.segments[i];\n            const distance = Math.hypot(head.x - segment.x, head.y - segment.y);\n            if (distance < head.radius + segment.radius * 0.5) {\n                return true;\n            }\n        }\n        return false;\n    }\n    checkCollisionWithPoint(point) {\n        // Skip the head\n        for(let i = 1; i < this.segments.length; i++){\n            const segment = this.segments[i];\n            const distance = Math.hypot(point.x - segment.x, point.y - segment.y);\n            if (distance < point.radius + segment.radius * 0.8) {\n                return true;\n            }\n        }\n        return false;\n    }\n    collectPowerUp(powerUp) {\n        this.activePowerUps.set(powerUp.type, Date.now() + powerUp.duration);\n        powerUp.applyEffect(this);\n        _audio_system__WEBPACK_IMPORTED_MODULE_0__.AudioSystem.getInstance().playSound(\"powerup\");\n    }\n    constructor(options){\n        this.segments = [];\n        this.velocity = {\n            x: 0,\n            y: 0\n        };\n        this.turningSpeed = 0.05;\n        this.history = [];\n        this.isInvulnerable = false;\n        this.isGhost = false;\n        this.activePowerUps = new Map();\n        this.angle = options.initialAngle;\n        this.speed = options.speed;\n        this.baseSpeed = options.speed;\n        this.color = options.color;\n        this.headColor = options.headColor;\n        this.targetLength = options.initialLength;\n        // Initialize first segment (head)\n        this.segments.push({\n            x: options.x,\n            y: options.y,\n            radius: 12 // Head is slightly larger\n        });\n        // Add initial body segments\n        for(let i = 1; i < options.initialLength; i++){\n            this.segments.push({\n                x: options.x - i * Math.cos(options.initialAngle) * 20,\n                y: options.y - i * Math.sin(options.initialAngle) * 20,\n                radius: 10\n            });\n        }\n        // Initialize history with head position\n        for(let i = 0; i < 1000; i++){\n            this.history.push({\n                x: options.x,\n                y: options.y\n            });\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb3dlclVwVHlwZSB9IGZyb20gJy4vcG93ZXItdXAnO1xyXG5pbXBvcnQgeyBBdWRpb1N5c3RlbSB9IGZyb20gJy4vYXVkaW8tc3lzdGVtJztcclxuXHJcbmludGVyZmFjZSBQb3dlclVwIHtcclxuICB0eXBlOiBQb3dlclVwVHlwZTtcclxuICBkdXJhdGlvbjogbnVtYmVyO1xyXG4gIGFwcGx5RWZmZWN0OiAoc25ha2U6IFNuYWtlKSA9PiB2b2lkO1xyXG59XHJcblxyXG4vLyBTbmFrZSBzZWdtZW50IGludGVyZmFjZVxyXG5pbnRlcmZhY2UgU25ha2VTZWdtZW50IHtcclxuICAgIHg6IG51bWJlclxyXG4gICAgeTogbnVtYmVyXHJcbiAgICByYWRpdXM6IG51bWJlclxyXG4gIH1cclxuICBcclxuICAvLyBTbmFrZSBvcHRpb25zIGludGVyZmFjZVxyXG4gIGludGVyZmFjZSBTbmFrZU9wdGlvbnMge1xyXG4gICAgeDogbnVtYmVyXHJcbiAgICB5OiBudW1iZXJcclxuICAgIGNvbG9yOiBzdHJpbmdcclxuICAgIGhlYWRDb2xvcjogc3RyaW5nXHJcbiAgICBpbml0aWFsTGVuZ3RoOiBudW1iZXJcclxuICAgIGluaXRpYWxBbmdsZTogbnVtYmVyXHJcbiAgICBzcGVlZDogbnVtYmVyXHJcbiAgfVxyXG4gIFxyXG4gIGV4cG9ydCBjbGFzcyBTbmFrZSB7XHJcbiAgICBzZWdtZW50czogU25ha2VTZWdtZW50W10gPSBbXVxyXG4gICAgdmVsb2NpdHkgPSB7IHg6IDAsIHk6IDAgfVxyXG4gICAgYW5nbGU6IG51bWJlclxyXG4gICAgc3BlZWQ6IG51bWJlclxyXG4gICAgYmFzZVNwZWVkOiBudW1iZXJcclxuICAgIHR1cm5pbmdTcGVlZCA9IDAuMDVcclxuICAgIGNvbG9yOiBzdHJpbmdcclxuICAgIGhlYWRDb2xvcjogc3RyaW5nXHJcbiAgICB0YXJnZXRMZW5ndGg6IG51bWJlclxyXG4gICAgaGlzdG9yeTogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9W10gPSBbXVxyXG4gICAgaXNJbnZ1bG5lcmFibGU6IGJvb2xlYW4gPSBmYWxzZVxyXG4gICAgaXNHaG9zdDogYm9vbGVhbiA9IGZhbHNlXHJcbiAgICBhY3RpdmVQb3dlclVwczogTWFwPFBvd2VyVXBUeXBlLCBudW1iZXI+ID0gbmV3IE1hcCgpXHJcbiAgXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTbmFrZU9wdGlvbnMpIHtcclxuICAgICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuaW5pdGlhbEFuZ2xlXHJcbiAgICAgIHRoaXMuc3BlZWQgPSBvcHRpb25zLnNwZWVkXHJcbiAgICAgIHRoaXMuYmFzZVNwZWVkID0gb3B0aW9ucy5zcGVlZFxyXG4gICAgICB0aGlzLmNvbG9yID0gb3B0aW9ucy5jb2xvclxyXG4gICAgICB0aGlzLmhlYWRDb2xvciA9IG9wdGlvbnMuaGVhZENvbG9yXHJcbiAgICAgIHRoaXMudGFyZ2V0TGVuZ3RoID0gb3B0aW9ucy5pbml0aWFsTGVuZ3RoXHJcbiAgXHJcbiAgICAgIC8vIEluaXRpYWxpemUgZmlyc3Qgc2VnbWVudCAoaGVhZClcclxuICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICB4OiBvcHRpb25zLngsXHJcbiAgICAgICAgeTogb3B0aW9ucy55LFxyXG4gICAgICAgIHJhZGl1czogMTIgLy8gSGVhZCBpcyBzbGlnaHRseSBsYXJnZXJcclxuICAgICAgfSlcclxuICBcclxuICAgICAgLy8gQWRkIGluaXRpYWwgYm9keSBzZWdtZW50c1xyXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG9wdGlvbnMuaW5pdGlhbExlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgIHg6IG9wdGlvbnMueCAtIGkgKiBNYXRoLmNvcyhvcHRpb25zLmluaXRpYWxBbmdsZSkgKiAyMCxcclxuICAgICAgICAgIHk6IG9wdGlvbnMueSAtIGkgKiBNYXRoLnNpbihvcHRpb25zLmluaXRpYWxBbmdsZSkgKiAyMCxcclxuICAgICAgICAgIHJhZGl1czogMTBcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIEluaXRpYWxpemUgaGlzdG9yeSB3aXRoIGhlYWQgcG9zaXRpb25cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcclxuICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCh7IHg6IG9wdGlvbnMueCwgeTogb3B0aW9ucy55IH0pXHJcbiAgICAgIH1cclxuICAgIH1cclxuICBcclxuICAgIHVwZGF0ZShjYW52YXNXaWR0aDogbnVtYmVyLCBjYW52YXNIZWlnaHQ6IG51bWJlcikge1xyXG4gICAgICAvLyBVcGRhdGUgdmVsb2NpdHkgYmFzZWQgb24gY3VycmVudCBhbmdsZVxyXG4gICAgICB0aGlzLnZlbG9jaXR5ID0ge1xyXG4gICAgICAgIHg6IE1hdGguY29zKHRoaXMuYW5nbGUpICogdGhpcy5zcGVlZCxcclxuICAgICAgICB5OiBNYXRoLnNpbih0aGlzLmFuZ2xlKSAqIHRoaXMuc3BlZWQsXHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLy8gTW92ZSBoZWFkXHJcbiAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLnNlZ21lbnRzWzBdXHJcbiAgICAgIGNvbnN0IG5ld1ggPSBoZWFkLnggKyB0aGlzLnZlbG9jaXR5LnhcclxuICAgICAgY29uc3QgbmV3WSA9IGhlYWQueSArIHRoaXMudmVsb2NpdHkueVxyXG4gIFxyXG4gICAgICAvLyBIYW5kbGUgd3JhcHBpbmcgYXJvdW5kIGVkZ2VzIChwZXJpb2RpYyBib3VuZGFyeSBjb25kaXRpb25zKVxyXG4gICAgICBsZXQgd3JhcHBlZFggPSBuZXdYXHJcbiAgICAgIGxldCB3cmFwcGVkWSA9IG5ld1lcclxuICBcclxuICAgICAgaWYgKG5ld1ggPCAwKSB3cmFwcGVkWCA9IGNhbnZhc1dpZHRoXHJcbiAgICAgIGlmIChuZXdYID4gY2FudmFzV2lkdGgpIHdyYXBwZWRYID0gMFxyXG4gICAgICBpZiAobmV3WSA8IDApIHdyYXBwZWRZID0gY2FudmFzSGVpZ2h0XHJcbiAgICAgIGlmIChuZXdZID4gY2FudmFzSGVpZ2h0KSB3cmFwcGVkWSA9IDBcclxuICBcclxuICAgICAgLy8gQWRkIG5ldyBwb3NpdGlvbiB0byBoaXN0b3J5XHJcbiAgICAgIHRoaXMuaGlzdG9yeS51bnNoaWZ0KHsgeDogd3JhcHBlZFgsIHk6IHdyYXBwZWRZIH0pXHJcbiAgICAgIHRoaXMuaGlzdG9yeSA9IHRoaXMuaGlzdG9yeS5zbGljZSgwLCAxMDAwKSAvLyBMaW1pdCBoaXN0b3J5IGxlbmd0aFxyXG4gIFxyXG4gICAgICAvLyBVcGRhdGUgaGVhZCBwb3NpdGlvblxyXG4gICAgICBoZWFkLnggPSB3cmFwcGVkWFxyXG4gICAgICBoZWFkLnkgPSB3cmFwcGVkWVxyXG4gIFxyXG4gICAgICAvLyBHcm93IHNuYWtlIGlmIG5lZWRlZFxyXG4gICAgICB0aGlzLmdyb3coMCkgLy8gVGhpcyB3aWxsIGhhbmRsZSBzZWdtZW50IHBvc2l0aW9uaW5nXHJcbiAgICB9XHJcbiAgXHJcbiAgICBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGN0eC5zYXZlKClcclxuICAgICAgXHJcbiAgICAgIC8vIEFwcGx5IHZpc3VhbCBlZmZlY3RzIGJhc2VkIG9uIHBvd2VyLXVwc1xyXG4gICAgICBpZiAodGhpcy5pc0ludnVsbmVyYWJsZSkge1xyXG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICcjZjBmJ1xyXG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMjBcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYgKHRoaXMuaXNHaG9zdCkge1xyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNlxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIERyYXcgYm9keSBzZWdtZW50c1xyXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5zZWdtZW50cy5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHRoaXMuc2VnbWVudHNbaV1cclxuICBcclxuICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICBjdHguYXJjKHNlZ21lbnQueCwgc2VnbWVudC55LCBzZWdtZW50LnJhZGl1cywgMCwgTWF0aC5QSSAqIDIpXHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3JcclxuICAgICAgICBjdHguZmlsbCgpXHJcbiAgXHJcbiAgICAgICAgLy8gQWRkIGdsb3cgZWZmZWN0XHJcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5jb2xvclxyXG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMTBcclxuICAgICAgICBjdHguZmlsbCgpXHJcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwXHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLy8gRHJhdyBoZWFkXHJcbiAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLnNlZ21lbnRzWzBdXHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICBjdHguYXJjKGhlYWQueCwgaGVhZC55LCBoZWFkLnJhZGl1cywgMCwgTWF0aC5QSSAqIDIpXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmhlYWRDb2xvclxyXG4gICAgICBjdHguZmlsbCgpXHJcbiAgXHJcbiAgICAgIC8vIEFkZCBnbG93IGVmZmVjdCB0byBoZWFkXHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuaGVhZENvbG9yXHJcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gMTVcclxuICAgICAgY3R4LmZpbGwoKVxyXG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDBcclxuICBcclxuICAgICAgLy8gRHJhdyBleWVzXHJcbiAgICAgIGNvbnN0IGV5ZU9mZnNldCA9IDNcclxuICAgICAgY29uc3QgZXllUmFkaXVzID0gMlxyXG4gIFxyXG4gICAgICAvLyBDYWxjdWxhdGUgZXllIHBvc2l0aW9ucyBiYXNlZCBvbiBhbmdsZVxyXG4gICAgICBjb25zdCBsZWZ0RXllWCA9IGhlYWQueCArIE1hdGguY29zKHRoaXMuYW5nbGUgLSAwLjMpICogZXllT2Zmc2V0XHJcbiAgICAgIGNvbnN0IGxlZnRFeWVZID0gaGVhZC55ICsgTWF0aC5zaW4odGhpcy5hbmdsZSAtIDAuMykgKiBleWVPZmZzZXRcclxuICAgICAgY29uc3QgcmlnaHRFeWVYID0gaGVhZC54ICsgTWF0aC5jb3ModGhpcy5hbmdsZSArIDAuMykgKiBleWVPZmZzZXRcclxuICAgICAgY29uc3QgcmlnaHRFeWVZID0gaGVhZC55ICsgTWF0aC5zaW4odGhpcy5hbmdsZSArIDAuMykgKiBleWVPZmZzZXRcclxuICBcclxuICAgICAgLy8gRHJhdyBsZWZ0IGV5ZVxyXG4gICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgY3R4LmFyYyhsZWZ0RXllWCwgbGVmdEV5ZVksIGV5ZVJhZGl1cywgMCwgTWF0aC5QSSAqIDIpXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmZcIlxyXG4gICAgICBjdHguZmlsbCgpXHJcbiAgXHJcbiAgICAgIC8vIERyYXcgcmlnaHQgZXllXHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICBjdHguYXJjKHJpZ2h0RXllWCwgcmlnaHRFeWVZLCBleWVSYWRpdXMsIDAsIE1hdGguUEkgKiAyKVxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmXCJcclxuICAgICAgY3R4LmZpbGwoKVxyXG4gIFxyXG4gICAgICBjdHgucmVzdG9yZSgpXHJcbiAgICB9XHJcbiAgXHJcbiAgICB0dXJuTGVmdCgpIHtcclxuICAgICAgdGhpcy5hbmdsZSAtPSB0aGlzLnR1cm5pbmdTcGVlZFxyXG4gICAgfVxyXG4gIFxyXG4gICAgdHVyblJpZ2h0KCkge1xyXG4gICAgICB0aGlzLmFuZ2xlICs9IHRoaXMudHVybmluZ1NwZWVkXHJcbiAgICB9XHJcbiAgXHJcbiAgICBib29zdCgpIHtcclxuICAgICAgdGhpcy5zcGVlZCA9IHRoaXMuYmFzZVNwZWVkICogMS41XHJcbiAgICB9XHJcbiAgXHJcbiAgICBub3JtYWxTcGVlZCgpIHtcclxuICAgICAgdGhpcy5zcGVlZCA9IHRoaXMuYmFzZVNwZWVkXHJcbiAgICB9XHJcbiAgXHJcbiAgICBncm93KGFtb3VudDogbnVtYmVyKSB7XHJcbiAgICAgIC8vIEluY3JlYXNlIHRhcmdldCBsZW5ndGhcclxuICAgICAgdGhpcy50YXJnZXRMZW5ndGggKz0gYW1vdW50XHJcbiAgXHJcbiAgICAgIC8vIEFkZCBzZWdtZW50cyBpZiBuZWVkZWRcclxuICAgICAgd2hpbGUgKHRoaXMuc2VnbWVudHMubGVuZ3RoIDwgdGhpcy50YXJnZXRMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSB0aGlzLnNlZ21lbnRzLmxlbmd0aCAtIDFcclxuICAgICAgICBjb25zdCBoaXN0b3J5SW5kZXggPSBNYXRoLm1pbihsYXN0SW5kZXggKiA1LCB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMSlcclxuICBcclxuICAgICAgICAvLyBHZXQgcG9zaXRpb24gZnJvbSBoaXN0b3J5XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmhpc3RvcnlbaGlzdG9yeUluZGV4XVxyXG4gIFxyXG4gICAgICAgIC8vIEFkZCBuZXcgc2VnbWVudFxyXG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICB4OiBwb3NpdGlvbi54LFxyXG4gICAgICAgICAgeTogcG9zaXRpb24ueSxcclxuICAgICAgICAgIHJhZGl1czogOCAtIE1hdGgubWluKDMsIHRoaXMuc2VnbWVudHMubGVuZ3RoICogMC4xKSwgLy8gR3JhZHVhbGx5IGRlY3JlYXNlIHNpemVcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgXHJcbiAgICBnZXRIZWFkKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zZWdtZW50c1swXVxyXG4gICAgfVxyXG4gIFxyXG4gICAgY2hlY2tTZWxmQ29sbGlzaW9uKCkge1xyXG4gICAgICBjb25zdCBoZWFkID0gdGhpcy5nZXRIZWFkKClcclxuICBcclxuICAgICAgLy8gU2tpcCB0aGUgZmlyc3QgZmV3IHNlZ21lbnRzIHRvIHByZXZlbnQgZmFsc2UgY29sbGlzaW9uc1xyXG4gICAgICBmb3IgKGxldCBpID0gMTA7IGkgPCB0aGlzLnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHRoaXMuc2VnbWVudHNbaV1cclxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguaHlwb3QoaGVhZC54IC0gc2VnbWVudC54LCBoZWFkLnkgLSBzZWdtZW50LnkpXHJcbiAgXHJcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgaGVhZC5yYWRpdXMgKyBzZWdtZW50LnJhZGl1cyAqIDAuNSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgXHJcbiAgICBjaGVja0NvbGxpc2lvbldpdGhQb2ludChwb2ludDogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgcmFkaXVzOiBudW1iZXIgfSkge1xyXG4gICAgICAvLyBTa2lwIHRoZSBoZWFkXHJcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5zZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSB0aGlzLnNlZ21lbnRzW2ldXHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmh5cG90KHBvaW50LnggLSBzZWdtZW50LngsIHBvaW50LnkgLSBzZWdtZW50LnkpXHJcbiAgXHJcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgcG9pbnQucmFkaXVzICsgc2VnbWVudC5yYWRpdXMgKiAwLjgpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIFxyXG4gICAgY29sbGVjdFBvd2VyVXAocG93ZXJVcDogUG93ZXJVcCkge1xyXG4gICAgICB0aGlzLmFjdGl2ZVBvd2VyVXBzLnNldChwb3dlclVwLnR5cGUsIERhdGUubm93KCkgKyBwb3dlclVwLmR1cmF0aW9uKVxyXG4gICAgICBwb3dlclVwLmFwcGx5RWZmZWN0KHRoaXMpXHJcbiAgICAgIEF1ZGlvU3lzdGVtLmdldEluc3RhbmNlKCkucGxheVNvdW5kKCdwb3dlcnVwJylcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgIl0sIm5hbWVzIjpbIkF1ZGlvU3lzdGVtIiwiU25ha2UiLCJ1cGRhdGUiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsInZlbG9jaXR5IiwieCIsIk1hdGgiLCJjb3MiLCJhbmdsZSIsInNwZWVkIiwieSIsInNpbiIsImhlYWQiLCJzZWdtZW50cyIsIm5ld1giLCJuZXdZIiwid3JhcHBlZFgiLCJ3cmFwcGVkWSIsImhpc3RvcnkiLCJ1bnNoaWZ0Iiwic2xpY2UiLCJncm93IiwiZHJhdyIsImN0eCIsInNhdmUiLCJpc0ludnVsbmVyYWJsZSIsInNoYWRvd0NvbG9yIiwic2hhZG93Qmx1ciIsImlzR2hvc3QiLCJnbG9iYWxBbHBoYSIsImkiLCJsZW5ndGgiLCJzZWdtZW50IiwiYmVnaW5QYXRoIiwiYXJjIiwicmFkaXVzIiwiUEkiLCJmaWxsU3R5bGUiLCJjb2xvciIsImZpbGwiLCJoZWFkQ29sb3IiLCJleWVPZmZzZXQiLCJleWVSYWRpdXMiLCJsZWZ0RXllWCIsImxlZnRFeWVZIiwicmlnaHRFeWVYIiwicmlnaHRFeWVZIiwicmVzdG9yZSIsInR1cm5MZWZ0IiwidHVybmluZ1NwZWVkIiwidHVyblJpZ2h0IiwiYm9vc3QiLCJiYXNlU3BlZWQiLCJub3JtYWxTcGVlZCIsImFtb3VudCIsInRhcmdldExlbmd0aCIsImxhc3RJbmRleCIsImhpc3RvcnlJbmRleCIsIm1pbiIsInBvc2l0aW9uIiwicHVzaCIsImdldEhlYWQiLCJjaGVja1NlbGZDb2xsaXNpb24iLCJkaXN0YW5jZSIsImh5cG90IiwiY2hlY2tDb2xsaXNpb25XaXRoUG9pbnQiLCJwb2ludCIsImNvbGxlY3RQb3dlclVwIiwicG93ZXJVcCIsImFjdGl2ZVBvd2VyVXBzIiwic2V0IiwidHlwZSIsIkRhdGUiLCJub3ciLCJkdXJhdGlvbiIsImFwcGx5RWZmZWN0IiwiZ2V0SW5zdGFuY2UiLCJwbGF5U291bmQiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJNYXAiLCJpbml0aWFsQW5nbGUiLCJpbml0aWFsTGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/snake.tsx\n"));

/***/ })

});